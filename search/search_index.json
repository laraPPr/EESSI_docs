{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the EESSI project documentation!","text":"<p>Quote</p> <p>What if there was a way to avoid having to install a broad range of scientific software from scratch on every HPC cluster or cloud instance you use or maintain, without compromising on performance?</p> <p>The European Environment for Scientific Software Installations (EESSI, pronounced as \"easy\") is a collaboration between different European partners in HPC community. The goal of this project is to build a common stack of scientific software installations for HPC systems and beyond, including laptops, personal workstations and cloud infrastructure.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>What is EESSI?</li> <li>Contact info</li> </ul> <p>For users:</p> <ul> <li><code>software.eessi.io</code> repository</li> <li>Access, initialize and use EESSI</li> <li>How to run EESSI test suite</li> <li>Get help or report issue</li> </ul> <p>For system administrators:</p> <ul> <li>EESSI layered structure: filesystem, compatibility, software</li> <li>Installing EESSI</li> <li>Setting up a mirror server</li> </ul> <p>For contributors:</p> <ul> <li>Adding software to EESSI</li> <li>Meetings</li> </ul> <p>The EESSI project was covered during a quick AWS HPC Tech Short video (15 June 2023):</p>"},{"location":"bot/","title":"Build-test-deploy bot","text":"<p>Building, testing, and deploying software is done by one or more bot instances.</p> <p>The EESSI build-test-deploy bot  is implemented as a GitHub App in the <code>eessi-bot-software-layer</code> repository.</p> <p>It operates in the context of pull requests to the <code>compatibility-layer</code> repository or the <code>software-layer</code> repository, and follows the instructions supplied by humans, so the procedure of adding software to EESSI is semi-automatic.</p> <p>It leverages the scripts provided in the <code>bot/</code> subdirectory of the target repository (see for example here), like <code>bot/build.sh</code> to build software, and <code>bot/check-result.sh</code> to check whether the software was built correctly.</p>"},{"location":"bot/#high-level-design","title":"High-level design","text":"<p>The bot  consists of two components: the event handler, and the job manager.</p>"},{"location":"bot/#event-handler","title":"Event handler","text":"<p>The bot event handler is responsible for handling GitHub events for the GitHub repositories it is registered to.</p> <p>It is triggered for every event that it receives from GitHub. Most events are ignored, but specific events trigger the bot to take action.</p> <p>Examples of actionable events are submitting of a comment that starts with <code>bot:</code>, which may specify an instruction for the bot like building software, or adding a <code>bot:deploy</code> label (see deploying).</p>"},{"location":"bot/#job-manager","title":"Job manager","text":"<p>The bot job manager is responsible for monitoring the queued and running jobs, and reporting back when jobs completed.</p> <p>It runs every couple of minutes as a cron job.</p>"},{"location":"bot/#basics","title":"Basics","text":"<p>Instructions for the bot  should always start with <code>bot:</code>.</p> <p>To get help from the bot, post a comment with <code>bot: help</code>.</p> <p>To make the bot report how it is configured, post a comment with <code>bot: show_config</code>.</p>"},{"location":"bot/#permissions","title":"Permissions","text":"<p>The bot  is configured to only act on instructions issued by specific GitHub accounts.</p> <p>There are separate configuration options for allowing to send instructions to the bot, to trigger building of software, and to deploy software installations in to the EESSI repository.</p> <p>Note</p> <p>Ask for help in the <code>#software-layer-bot</code> channel of the EESSI Slack if needed!</p>"},{"location":"bot/#building","title":"Building","text":"<p>To instruct the bot  to build software, one or more <code>build</code> instructions should be issued by posting a comment in the pull request (see also here).</p> <p>The most basic build instruction that can be sent to the bot is:</p> <pre><code>bot: build\n</code></pre> <p>Warning</p> <p>Only use <code>bot: build</code> if you are confident that it is OK to do so.</p> <p>Most likely, you want to supply one or more filters to avoid that the bot builds for all its configurations.</p>"},{"location":"bot/#filters","title":"Filters","text":"<p>Build instructions can include filters that are applied by each bot instance to determine which builds should be executed, based on:</p> <ul> <li><code>instance</code>: the <code>name</code> of the bot instance, for example <code>instance:aws</code> for the bot instance running in AWS;</li> <li><code>repository</code>: the target repository, for example <code>eessi-2023.06-software</code> which corresponds to the 2023.06 version of the EESSI software layer;</li> <li><code>architecture</code>: the name of the CPU microarchitecture, for example <code>x86_64/amd/zen2</code>;</li> </ul> <p>Note</p> <p>Use <code>:</code> as separator to specify a value for a particular filter, do not add spaces after the <code>:</code>.</p> <p>The bot recognizes shorthands for the supported filters, so you can use <code>inst:...</code> instead of <code>instance:...</code>, <code>repo:...</code> instead of <code>repository:...</code>, and <code>arch:...</code> instead of <code>architecture:...</code>.</p>"},{"location":"bot/#combining-filters","title":"Combining filters","text":"<p>You can combine multiple filters in a single <code>build</code> instruction. Separate filters with a space, order of filters does not matter.</p> <p>For example:</p> <pre><code>bot: build repo:eessi-hpc.org-2023.06-software arch:x86_64/amd/zen2\n</code></pre>"},{"location":"bot/#multiple-build-instructions","title":"Multiple build instructions","text":"<p>You can issue multiple build instructions in a single comment, even across multiple bot instances, repositories, and CPU targets. Specify one build instruction per line.</p> <p>For example:</p> <pre><code>bot: build repo:eessi-hpc.org-2023.06-software arch:x86_64/amd/zen3 inst:aws\nbot: build repo:eessi-hpc.org-2023.06-software arch:aarch64/generic inst:azure\n</code></pre> <p>Note</p> <p>The bot applies the filters with partial matching, which you can use to combine multiple build instructions into a single one.</p> <p>For example, if you only want to build for all <code>aarch64</code> CPU targets, you can use <code>arch:aarch64</code> as filter.</p> <p>The same applies to the <code>instance</code> and <code>repository</code> filters.</p>"},{"location":"bot/#behind-the-scenes","title":"Behind-the-scenes","text":""},{"location":"bot/#processing-build-instructions","title":"Processing build instructions","text":"<p>When the bot receives build instructions through a comment in a pull request, they are processed by the event handler component. It will:</p> <p>1) Combine its active configuration (instance name, repositories, supported CPU targets)    and the build instructions to prepare a list of jobs to submit;</p> <p>2) Create a working directory for each job, including a Slurm job script that    runs the <code>bot/build.sh</code> script in the context of the changes proposed in the pull request to build the    software, and runs <code>bot/check-result.sh</code> script at the end to check whether the build was successful;</p> <p>3) Submit each prepared job to a workernode that can build for the specified CPU target, and put a hold on it.</p>"},{"location":"bot/#managing-build-jobs","title":"Managing build jobs","text":"<p>During the next iteration of the job manager, the submitted jobs are released and queued for execution.</p> <p>The job manager also monitors the running jobs at regular intervals, and reports back in the pull request when a job has completed. It also reports the result (<code>SUCCESS</code>  or <code>FAILURE</code> ), based on the result of the <code>bot/check-result.sh</code> script.</p>"},{"location":"bot/#artefacts","title":"Artefacts","text":"<p>If all goes well, each job should produce a tarball as an artefact, which contains the software installations and the corresponding environment module files.</p> <p>The message reported by the job manager provides an overview of the contents of the artefact, which was created by the <code>bot/check-result.sh</code> script.</p>"},{"location":"bot/#testing","title":"Testing","text":"<p>Warning</p> <p>The test phase is not implemented yet in the bot.</p> <p>We intend to use the EESSI test suite in different OS configurations to verify that the software that was built works as expected.</p>"},{"location":"bot/#deploying","title":"Deploying","text":"<p>To deploy the artefacts that were obtained in the build phase, you should add the <code>bot: deploy</code> label to the pull request.</p> <p>This will trigger the event handler to upload the artefacts for ingestion into the EESSI repository.</p>"},{"location":"bot/#behind-the-scenes_1","title":"Behind-the-scenes","text":"<p>The current setup for the software-layer repository, is as follows:</p> <ul> <li>The bot deploys the artefacts (tarballs) to an S3 bucket in AWS, along with a metadata file, using the   <code>eessi-upload-to-staging</code> script;</li> <li>A cron job that runs every couple of minutes on the CernVM-FS Stratum-0 server opens a pull request to   the (private) EESSI/staging repository, to move the metadata file for   each uploaded tarball from the <code>staged</code> to the <code>approved</code> directory;</li> <li>Once that pull request gets merged, the target is automatically ingested into the EESSI repository by a cron job   on the Stratum-0 server, and the metadata file is moved from <code>approved</code> to <code>ingested</code> in the <code>EESSI/staging</code> repository;</li> </ul>"},{"location":"compatibility_layer/","title":"Compatibility layer","text":"<p>The middle layer of the EESSI project is the compatibility layer, which ensures that our scientific software stack is compatible with different client operating systems (different Linux distributions, macOS and even Windows via WSL).</p> <p>For this we rely on Gentoo Prefix, by installing a limited set of Gentoo Linux packages in a non-standard location (a \"prefix\"), using Gentoo's package manager Portage.</p> <p>The compatible layer is maintained via our https://github.com/EESSI/compatibility-layer GitHub repository.</p>"},{"location":"contact/","title":"Contact info","text":"<p>For more information:</p> <ul> <li>visit our website https://www.eessi.io</li> <li>consult our documentation at https://eessi.github.io</li> <li>ask for help at our support portal</li> <li>join our Slack channel</li> <li>reach out to one of the project partners</li> <li>check out our GitHub repositories at https://github.com/EESSI</li> <li>follow us on Twitter: https://twitter.com/eessi_hpc</li> </ul> <p></p>"},{"location":"filesystem_layer/","title":"Filesystem layer","text":""},{"location":"filesystem_layer/#cernvm-file-system-cernvm-fs","title":"CernVM File System (CernVM-FS)","text":"<p>The bottom layer of the EESSI project is the filesystem layer, which is responsible for distributing the software stack.</p> <p>For this we rely on CernVM-FS (or CVMFS for short), a network file system used to distribute the software to the clients in a fast, reliable and scalable way.</p> <p>CVMFS was created over 10 years ago specifically for the purpose of globally distributing a large software stack. For the experiments at the Large Hadron Collider, it hosts several hundred million files and directories that are distributed to the order of hundred thousand client computers.</p> <p></p> <p>The hierarchical structure with multiple caching layers (Stratum-0, Stratum-1's located at partner sites and local caching proxies) ensures good performance with limited resources. Redundancy is provided by using multiple Stratum-1's at various sites. Since CVMFS is based on the HTTP protocol, the ubiquitous Squid caching proxy can be leveraged to reduce server loads and improve performance at large installations (such as HPC clusters). Clients can easily mount the file system (read-only) via a FUSE (Filesystem in Userspace) module.</p> <p>For a (basic) introduction to CernVM-FS, see this presentation.</p> <p>Detailed information about how we configure CVMFS is available at https://github.com/EESSI/filesystem-layer.</p>"},{"location":"filesystem_layer/#eessi-infrastructure","title":"EESSI infrastructure","text":"<p>For both the pilot and production repositories, EESSI hosts a CernVM-FS Stratum 0 and a number of public Stratum 1 servers. Client systems using EESSI by default connect against the public EESSI CernVM-FS Stratum 1 servers. The status of the infrastructure for the pilot repository is displayed at http://status.eessi-infra.org, while for the production repository it is displayed at https://status.eessi.io.</p>"},{"location":"gpu/","title":"GPU support","text":"<p>More information on the actions that must be performed to ensure that GPU software included in EESSI can use the GPU in your system is available below.</p> <p>Please open a support issue if you need help or have questions regarding GPU support.</p> <p>Make sure the <code>${EESSI_VERSION}</code> version placeholder is defined!</p> <p>In this page, we use <code>${EESSI_VERSION}</code> as a placeholder for the version of the EESSI repository, for example: <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}\n</code></pre></p> <p>Before inspecting paths, or executing any of the specified commands, you should define <code>$EESSI_VERSION</code> first, for example with: <pre><code>export EESSI_VERSION=2023.06\n</code></pre></p>"},{"location":"gpu/#nvidia","title":"Support for using NVIDIA GPUs","text":"<p>EESSI supports running CUDA-enabled software. All CUDA-enabled modules are marked with the <code>(gpu)</code> feature, which is visible in the output produced by <code>module avail</code>.</p>"},{"location":"gpu/#nvidia_drivers","title":"NVIDIA GPU drivers","text":"<p>For CUDA-enabled software to run, it needs to be able to find the NVIDIA GPU drivers of the host system. The challenge here is that the NVIDIA GPU drivers are not always in a standard system location, and that we can not install the GPU drivers in EESSI (since they are too closely tied to the client OS and GPU hardware).</p>"},{"location":"gpu/#cuda_sdk","title":"Compiling CUDA software","text":"<p>An additional requirement is necessary if you want to be able to compile CUDA-enabled software using a CUDA installation included in EESSI. This requires a full CUDA SDK, but the CUDA SDK End User License Agreement (EULA) does not allow for full redistribution. In EESSI, we are (currently) only allowed to redistribute the files needed to run CUDA software.</p> <p>Full CUDA SDK only needed to compile CUDA software</p> <p>Without a full CUDA SDK on the host system, you will still be able to run CUDA-enabled software from the EESSI stack, you just won't be able to compile additional CUDA software.</p> <p>Below, we describe how to make sure that the EESSI software stack can find your NVIDIA GPU drivers and (optionally) full installations of the CUDA SDK.</p>"},{"location":"gpu/#host_injections","title":"<code>host_injections</code> variant symlink","text":"<p>In the EESSI repository, a special directory has been prepared where system administrators can install files that can be picked up by software installations included in EESSI. This gives the ability to administrators to influence the behaviour (and capabilities) of the EESSI software stack.</p> <p>This special directory is located in <code>/cvmfs/software.eessi.io/host_injections</code>, and it is a CernVM-FS Variant Symlink: a symbolic link for which the target can be controlled by the CernVM-FS client configuration (for more info, see 'Variant Symlinks' in the official CernVM-FS documentation).</p> <p>Default target for <code>host_injections</code> variant symlink</p> <p>Unless otherwise configured in the CernVM-FS client configuration for the EESSI repository, the <code>host_injections</code> symlink points to <code>/opt/eessi</code> on the client system: <pre><code>$ ls -l /cvmfs/software.eessi.io/host_injections\nlrwxrwxrwx 1 cvmfs cvmfs 10 Oct  3 13:51 /cvmfs/software.eessi.io/host_injections -&gt; /opt/eessi\n</code></pre></p> <p>As an example, let's imagine that we want to use a architecture-specific location on a shared filesystem as the target for the symlink. This has the advantage that one can make changes under <code>host_injections</code> that affect all nodes which share that CernVM-FS configuration. Configuring this in your CernVM-FS configuration would mean adding the following line in the client configuration file:</p> <pre><code>EESSI_HOST_INJECTIONS=/shared_fs/path\n</code></pre> <p>Don't forget to reload the CernVM-FS configuration</p> <p>After making a change to a CernVM-FS configuration file, you also need to reload the configuration: <pre><code>sudo cvmfs_config reload\n</code></pre></p> <p>All CUDA-enabled software in EESSI expects the CUDA drivers to be available in a specific subdirectory of this <code>host_injections</code> directory. In addition, installations of the CUDA SDK included EESSI are stripped down to the files that we are allowed to redistribute; all other files are replaced by symbolic links that point to another specific subdirectory of <code>host_injections</code>. For example: <pre><code>$ ls -l /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc\nlrwxrwxrwx 1 cvmfs cvmfs 109 Dec 21 14:49 /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc -&gt; /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc\n</code></pre></p> <p>If the corresponding full installation of the CUDA SDK is available there, the CUDA installation included in EESSI can be used to build CUDA software.</p>"},{"location":"gpu/#nvidia_eessi_native","title":"Using NVIDIA GPUs via a native EESSI installation","text":"<p>Here, we describe the steps to enable GPU support when you have a native EESSI installation on your system.</p> <p>Required permissions</p> <p>To enable GPU support for EESSI on your system, you will typically need to have system administration rights, since you need write permissions on the folder to the target directory of the <code>host_injections</code> symlink.</p>"},{"location":"gpu/#exposing-nvidia-gpu-drivers","title":"Exposing NVIDIA GPU drivers","text":"<p>To install the symlinks to your GPU drivers in <code>host_injections</code>, run the <code>link_nvidia_host_libraries.sh</code> script that is included in EESSI:</p> <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/link_nvidia_host_libraries.sh\n</code></pre> <p>This script uses <code>ldconfig</code> on your host system to locate your GPU drivers, and creates symbolic links to them in the correct location under <code>host_injections</code> directory. It also stores the CUDA version supported by the driver that the symlinks were created for.</p> <p>Re-run <code>link_nvidia_host_libraries.sh</code> after NVIDIA GPU driver update</p> <p>You should re-run this script every time you update the NVIDIA GPU drivers on the host system.</p> <p>Note that it is safe to re-run the script even if no driver updates were done: the script should detect that the current version of the drivers were already symlinked.</p>"},{"location":"gpu/#installing-full-cuda-sdk-optional","title":"Installing full CUDA SDK (optional)","text":"<p>To install a full CUDA SDK under <code>host_injections</code>, use the <code>install_cuda_host_injections.sh</code> script that is included in EESSI:</p> <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh\n</code></pre> <p>For example, to install CUDA 12.1.1 in the directory that the <code>host_injections</code> variant symlink points to, using <code>/tmp/$USER/EESSI</code> as directory to store temporary files: <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh --cuda-version 12.1.1 --temp-dir /tmp/$USER/EESSI --accept-cuda-eula\n</code></pre> You should choose the CUDA version you wish to install according to what CUDA versions are included in EESSI; see the output of <code>module avail CUDA/</code> after setting up your environment for using EESSI.</p> <p>You can run <code>/cvmfs/software.eessi.io/scripts/install_cuda_host_injections.sh --help</code> to check all of the options.</p> <p>Tip</p> <p>This script uses EasyBuild to install the CUDA SDK. For this to work, two requirements need to be satisfied:</p> <ul> <li><code>module load EasyBuild</code> should work (or the <code>eb</code> command is already available in the environment);</li> <li>The version of EasyBuild being used should provide the requested version of the CUDA easyconfig file   (in the example case above, that's <code>CUDA-12.1.1.eb</code>).</li> </ul> <p>You can rely on the EasyBuild installation that is included in EESSI for this.</p> <p>Alternatively, you may load an EasyBuild module manually before running the <code>install_cuda_host_injections.sh</code> script to make an <code>eb</code> command available.</p>"},{"location":"gpu/#nvidia_eessi_container","title":"Using NVIDIA GPUs via EESSI in a container","text":"<p>We focus here on the Apptainer/Singularity use case, and have only tested the <code>--nv</code> option to enable access to GPUs from within the container.</p> <p>If you are using the EESSI container to access the EESSI software, the procedure for enabling GPU support is slightly different and will be documented here eventually.</p>"},{"location":"gpu/#exposing-nvidia-gpu-drivers_1","title":"Exposing NVIDIA GPU drivers","text":"<p>When running a container with <code>apptainer</code> or <code>singularity</code> it is not necessary to run the <code>install_cuda_host_injections.sh</code> script since both these tools use <code>$LD_LIBRARY_PATH</code> internally in order to make the host GPU drivers available in the container.</p> <p>The only scenario where this would be required is if <code>$LD_LIBRARY_PATH</code> is modified or undefined.</p>"},{"location":"gpu/#gpu_cuda_testing","title":"Testing the GPU support","text":"<p>The quickest way to test if software installations included in  EESSI can access and use your GPU is to run the <code>deviceQuery</code> executable that is part of the <code>CUDA-Samples</code> module: <pre><code>module load CUDA-Samples\ndeviceQuery\n</code></pre> If both are successful, you should see information about your GPU printed to your terminal.</p>"},{"location":"meetings/","title":"Meetings","text":""},{"location":"meetings/#monthly-meetings-online","title":"Monthly meetings (online)","text":"<p>Online EESSI update meeting, every 1st Thursday of the month at 14:00 CE(S)T.</p> <p>More info via EESSI wiki.</p>"},{"location":"meetings/#physical-meetings","title":"Physical meetings","text":"<ul> <li>EESSI Community Meeting in Amsterdam (NL), 14-16 Sept 2022</li> </ul>"},{"location":"meetings/#physical-meetings-archive","title":"Physical meetings (archive)","text":""},{"location":"meetings/#2019","title":"2019","text":"<ul> <li>Meeting in Cambridge (UK), 20-21 May 2019</li> </ul>"},{"location":"meetings/#2020","title":"2020","text":"<ul> <li>Meeting in Groningen (NL), 16 Jan 2020</li> <li>Meeting in Delft (NL), 5 Mar 2020</li> </ul>"},{"location":"overview/","title":"Overview of the EESSI project","text":""},{"location":"overview/#scope-goals","title":"Scope &amp; Goals","text":"<p>Through the EESSI project, we want to set up a shared stack of scientific software installations, and by doing so avoid a lot of duplicate work across HPC sites.</p> <p>For end users, we want to provide a uniform user experience with respect to available scientific software, regardless of which system they use.</p> <p>Our software stack should work on laptops, personal workstations, HPC clusters and in the cloud, which means we will need to support different CPUs, networks, GPUs, and so on. We hope to make this work for any Linux distribution and maybe even macOS and Windows via WSL, and a wide variety of CPU architectures (Intel, AMD, ARM, POWER, RISC-V).</p> <p>Of course we want to focus on the performance of the software, but also on automating the workflow for maintaining the software stack, thoroughly testing the installations, and collaborating efficiently.</p>"},{"location":"overview/#inspiration","title":"Inspiration","text":"<p>The EESSI concept is heavily inspired by Compute Canada software stack, which is a shared software stack used on all 5 major national systems in Canada and a bunch of smaller ones.</p> <p>The design of the Compute Canada software stack is discussed in detail in the PEARC'19 paper \"Providing a Unified Software Environment for Canada\u2019s National Advanced Computing Centers\".</p> <p>It has also been presented at the 5th EasyBuild User Meetings (slides, recorded talk), and is well documented.</p>"},{"location":"overview/#layered-structure","title":"Layered structure","text":"<p>The EESSI project consists of 3 layers.</p> <p></p> <p>The bottom layer is the filesystem layer, which is responsible for distributing the software stack across clients.</p> <p>The middle layer is a compatibility layer, which ensures that the software stack is compatible with multiple different client operating systems.</p> <p>The top layer is the software layer, which contains the actual scientific software applications and their dependencies.</p> <p>The host OS still provides a couple of things, like drivers for network and GPU, support for shared filesystems like GPFS and Lustre, a resource manager like Slurm, and so on.</p>"},{"location":"overview/#opportunities","title":"Opportunities","text":"<p>We hope to collaborate with interested parties across the HPC community, including HPC centres, vendors, consultancy companies and scientific software developers.</p> <p>Through our software stack, HPC users can seamlessly hop between sites, since the same software is available everywhere.</p> <p>We can leverage each others work with respect to providing tested and properly optimized scientific software installations more efficiently, and provide a platform for easy benchmarking of new systems.</p> <p>By working together with the developers of scientific software we can provide vetted installations for the broad HPC community.</p>"},{"location":"overview/#challenges","title":"Challenges","text":"<p>There are many challenges in an ambitious project like this, including (but probably not limited to):</p> <ul> <li>Finding time and manpower to get the software stack set up properly;</li> <li>Leveraging system sources like network interconnect (MPI &amp; co), accelerators (GPUs), ...;</li> <li>Supporting CPU architectures other than x86_64, including ARM, POWER, RISC-V, ...</li> <li>Dealing with licensed software, like Intel tools, MATLAB, ANSYS, ...;</li> <li>Integration with resource managers (Slurm) and vendor provided software (Cray PE);</li> <li>Convincing HPC site admins to adopt EESSI;</li> </ul>"},{"location":"overview/#current-status","title":"Current status","text":"<p>(June 2020)</p> <p>We are actively working on the EESSI repository, and are organizing monthly meetings to discuss progress and next steps forward.</p> <p>Keep an eye on our GitHub repositories at https://github.com/EESSI and our Twitter feed.</p>"},{"location":"partners/","title":"Project partners","text":""},{"location":"partners/#delft-university-of-technology-the-netherlands","title":"Delft University of Technology (The Netherlands)","text":"<ul> <li>Robbert Eggermont</li> <li>Koen Mulderij</li> </ul>"},{"location":"partners/#dell-technologies-europe","title":"Dell Technologies (Europe)","text":"<ul> <li>Walther Blom, High Education &amp; Research</li> <li>Jaco van Dijk, Higher Education</li> </ul>"},{"location":"partners/#eindhoven-university-of-technology","title":"Eindhoven University of Technology","text":"<ul> <li>Patrick Van Brakel</li> </ul>"},{"location":"partners/#ghent-university-belgium","title":"Ghent University (Belgium)","text":"<ul> <li>Kenneth Hoste, HPC-UGent</li> </ul>"},{"location":"partners/#hpcnow-spain","title":"HPCNow! (Spain)","text":"<ul> <li>Oriol Mula Valls</li> </ul>"},{"location":"partners/#julich-supercomputing-centre-germany","title":"J\u00fclich Supercomputing Centre (Germany)","text":"<ul> <li>Alan O'Cais</li> </ul>"},{"location":"partners/#university-of-cambridge-united-kingdom","title":"University of Cambridge (United Kingdom)","text":"<ul> <li>Mark Sharpley, Research Computing Services Division</li> </ul>"},{"location":"partners/#university-of-groningen-the-netherlands","title":"University of Groningen (The Netherlands)","text":"<ul> <li>Bob Dr\u00f6ge, Center for Information Technology</li> <li>Henk-Jan Zilverberg, Center for Information Technology</li> </ul>"},{"location":"partners/#university-of-twente-the-netherlands","title":"University of Twente (The Netherlands)","text":"<ul> <li>Geert Jan Laanstra, Electrical Engineering, Mathematics and Computer Science (EEMCS)</li> </ul>"},{"location":"partners/#university-of-oslo-norway","title":"University of Oslo (Norway)","text":"<ul> <li>Terje Kvernes</li> </ul>"},{"location":"partners/#university-of-bergen-norway","title":"University of Bergen (Norway)","text":"<ul> <li>Thomas R\u00f6blitz</li> </ul>"},{"location":"partners/#vrije-universiteit-amsterdam-the-netherlands","title":"Vrije Universiteit Amsterdam (The Netherlands)","text":"<ul> <li>Peter Stol</li> </ul>"},{"location":"partners/#surf-the-netherlands","title":"SURF (The Netherlands)","text":"<ul> <li>Caspar van Leeuwen</li> <li>Marco Verdicchio</li> <li>Bas van der Vlies</li> </ul>"},{"location":"software_layer/","title":"Software layer","text":"<p>The top layer of the EESSI project is the software layer, which provides the actual scientific software installations.</p> <p>To install the software we include in our stack, we use EasyBuild, a framework for installing scientific software on HPC systems. These installations are optimized for a particular system architecture (specific CPU and GPU generation).</p> <p>To access these software installation we provide environment module files and use Lmod, a modern environment modules tool which has been widely adopted in the HPC community in recent years.</p> <p>We leverage the archspec Python library to automatically select the best suited part of the software stack for a particular host, based on its system architecture.</p> <p>The software layer is maintained through our https://github.com/EESSI/software-layer GitHub repository.</p>"},{"location":"software_testing/","title":"Software testing","text":"<p>This page has been replaced with test-suite, update your bookmarks!</p>"},{"location":"support/","title":"Getting support for EESSI","text":"<p>Thanks to the MultiXscale EuroHPC project we are able to provide support to the users of EESSI. </p> <p>The EESSI support portal is hosted in GitLab: https://gitlab.com/eessi/support.</p>"},{"location":"support/#open-issue","title":"How to report a problem or ask a question","text":"<p>We recommend you to use a GitLab account if you want to get help from the EESSI support team.</p> <p>If you have a GitLab account you can submit your problems or questions on  EESSI via the issue tracker of the EESSI support portal at https://gitlab.com/eessi/support/-/issues. Please use one of the provided templates (report a problem, software request, question, ...) when creating an issue.</p> <p>You can also contact us via our e-mail address <code>support (@) eessi.io</code>, which will automatically create a (private) issue in the EESSI support portal. When you send us an email, please provide us with as much information as possible on your question or problem. You can find an overview of the information that we would like to receive in the README of the EESSI support portal.</p>"},{"location":"support/#level-of-support","title":"Level of Support","text":"<p>We provide support for EESSI according to a \"reasonable effort\" standard. That means we will go into reasonable effort to help you, but we may not have the time to explore every potential cause, and it may not lead to a (quick) solution. You can compare this to the level of support you typically get from other active open source projects.</p> <p>Note that the more complete your reported issue is (e.g. description of the error, what you ran, the software environment in which you ran, minimal reproducer, etc.) the bigger the chance is that we can help you with \"reasonable effort\".</p>"},{"location":"support/#what-do-we-provide-support-for","title":"What do we provide support for","text":""},{"location":"support/#accessing-and-using-the-eessi-software-stack","title":"Accessing and using the EESSI software stack","text":"<p>If you have trouble connecting to the software stack, such as trouble related to installing or configuring CernVM-FS to access the EESSI filesystem layer, or running the software installations included in the EESSI compatibility layer or software layer, please contact us.</p> <p>Note that we can only help with problems related to the software installations (getting the software to run, to perform as expected, etc.). We do not provide support for using specific features of the provided software, nor can we fix (known or unknown) bugs in the software included in EESSI. We can only help with diagnosing and fixing problems that are caused by how the software was built and installed in EESSI.</p>"},{"location":"support/#software-requests","title":"Software requests","text":"<p>We are open to software requests for software that is not included in EESSI yet.</p> <p>The quickest way to add additional software to EESSI is by contributing it yourself as a community contribution, please see the documentation on adding software.</p> <p>Alternatively, you can send in a request to our support team. Please try to provide as much information on the software as possible: preferably use the issue template (which requires you to log in to GitLab), or make sure to cover the items listed here.</p> <p>Be aware that we can only provide software that has an appropriate open source license.</p>"},{"location":"support/#eessi-test-suite","title":"EESSI test suite","text":"<p>If you are using the EESSI test suite, you can get help via the EESSI support portal.</p>"},{"location":"support/#build-and-deploy-bot","title":"Build-and-deploy bot","text":"<p>If you are using the EESSI build-and-deploy bot, you can get help via the EESSI support portal.</p>"},{"location":"support/#what-do-we-not-provide-support-for","title":"What do we not provide support for","text":"<p>Do not contact the EESSI support team to get help with using software that is included in EESSI, unless you think the problems you are seeing are related to how the software was built and installed.</p> <p>Please consult the documentation of the software you are using, or contact the developers of the software directly, if you have questions regarding using the software, or if you think you have found a bug.</p> <p>Funded by the European Union. This work has received funding from the European High Performance Computing Joint Undertaking (JU) and countries participating in the project under grant agreement No 101093169.</p>"},{"location":"talks/","title":"Talks related to EESSI","text":""},{"location":"talks/#2023","title":"2023","text":"<ul> <li>Streaming Optimised Scientific Software: an Introduction to EESSI (online tutorial, 5 Dec 2023)</li> <li>Best Practices for CernVM-FS in HPC (online tutorial, 4 Dec 2023)</li> <li>Streaming optimized scientific software installations on any Linux distro with EESSI (PackagingCon 2023, 27 Oct 2023)</li> <li>Making scientific software EESSI - and fast (8-min AWS HPC Tech Short, 15 June 2023)</li> </ul>"},{"location":"adding_software/building_software/","title":"Building software","text":"<p>(for maintainers)</p>"},{"location":"adding_software/building_software/#bot_build","title":"Instructing the bot to build","text":"<p>Once the pull request is open, you can instruct the bot  to build the software by posting a comment.</p> <p>For more information, see the building section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger building of software must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/building_software/#guidelines","title":"Guidelines","text":"<ul> <li> <p>It may be wise to let the bot perform a test build first, rather than letting it build for a wide range   of CPU targets.</p> </li> <li> <p>If one of the builds failed, you can let the bot retry that specific build.</p> </li> <li> <p>Make sure that the software has been built correctly for all CPU targets before you deploy!</p> </li> </ul>"},{"location":"adding_software/building_software/#checking-the-builds","title":"Checking the builds","text":"<p>If all goes well, you should see <code>SUCCESS</code>  for each build, along with button  to get more information about the checks that were performed, and metadata information on the resulting artefact .</p> <p>Note</p> <p>Make sure the result is what you expect it to be for all builds before you deploy!</p>"},{"location":"adding_software/building_software/#failing-builds","title":"Failing builds","text":"<p>Warning</p> <p>The bot will currently not give you any information on how or why a build is failing.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/building_software/#instructing-the-bot-to-deploy","title":"Instructing the bot to deploy","text":"<p>To make the bot  deploy the successfully built software, you should issue the corresponding instruction to the bot.</p> <p>For more information, see the deploying section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger deployment of software installations must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/building_software/#merging-the-pull-request","title":"Merging the pull request","text":"<p>You should be able to verify in the pull request that the ingestion has been done, since the CI should fail  initially to indicate that some software installations listed in your modified easystack are missing.</p> <p>Once the ingestion has been done, simply re-triggering the CI workflow should be sufficient to make it pass , and then the pull request can be merged.</p> <p>Note</p> <p>This assumes that the easystack file being modified is considered by the CI workflow file (<code>.github/workflows/test_eessi.yml</code>) that checks for missing installations, in the correct branch (for example <code>2023.06</code>) of the software-layer.</p> <p>If that's not the case yet, update this workflow in your pull request as well to add the missing easystack file!</p> <p>Warning</p> <p>You need permissions to re-trigger CI workflows and merge pull requests in the software-layer repository.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/building_software/#getting-help","title":"Getting help","text":"<p>If you have any questions, or if you need help with something, don't hesitate to contact us via the <code>#software-layer</code> channel of the EESSI Slack.</p>"},{"location":"adding_software/contribution_policy/","title":"Contribution policy","text":"<p>(version v0.1.0 - updated 9 Nov 2023)</p> <p>Note</p> <p>This policy is subject to change, please check back regularly.</p>"},{"location":"adding_software/contribution_policy/#purpose","title":"Purpose","text":"<p>The purpose of this contribution policy is to provide guidelines for adding software to EESSI.</p> <p>It informs about what requirements must be met in order for software to be eligible for inclusion in the EESSI software layer.</p>"},{"location":"adding_software/contribution_policy/#requirements","title":"Requirements","text":"<p>The following requirements must be taken into account when adding software to EESSI.</p> <p>Note that additional restrictions may apply in specific cases that are currently not covered explicitly by this policy.</p>"},{"location":"adding_software/contribution_policy/#freely_redistributable_software","title":"i) Freely redistributable software","text":"<p>Only freely redistributable software can be added to the EESSI repository, and we strongly prefer including only open source software in EESSI.</p> <p>Make sure that you are aware of the relevant software licenses, and that redistribution of the software you want to add to EESSI is allowed.</p> <p>For more information about a specific software license, see the SPDX license list.</p> <p>Note</p> <p>We intend to automatically verify that this requirement is met, by requiring that the SPDX license identifier is provided for all software included in EESSI.</p>"},{"location":"adding_software/contribution_policy/#built_by_bot","title":"ii) Built by the bot","text":"<p>All software included in the EESSI repository must be built autonomously by our bot .</p> <p>For more information, see our semi-automatic software installation procedure.</p>"},{"location":"adding_software/contribution_policy/#easybuild","title":"iii) Built and installed with EasyBuild","text":"<p>We currently require that all software installations in EESSI are built and installed using EasyBuild.</p> <p>We strongly prefer that the latest release of EasyBuild that is available at the time is used to add software to EESSI.</p> <p>The use of <code>--from-pr</code> and <code>--include-easyblocks-from-pr</code> to pull in changes to EasyBuild that are required to make the installation work correctly in EESSI is allowed, but only if that is strictly required (that is, if those changes are not included yet in the latest EasyBuild release).</p>"},{"location":"adding_software/contribution_policy/#supported_toolchain","title":"iv) Supported compiler toolchain","text":"<p>A compiler toolchain that is still supported by the latest EasyBuild release must be used for building the software.</p> <p>For more information on supported toolchains, see the EasyBuild toolchain support policy.</p>"},{"location":"adding_software/contribution_policy/#recent_toolchains","title":"v) Recent toolchain versions","text":"<p>We strongly prefer adding software to EESSI that was built with a recent compiler toolchain.</p> <p>When adding software to a particular version of EESSI, you should use a toolchain version that is already installed.</p> <p>If you would like to see an additional toolchain version being added to a particular version of EESSI, please open a support request for this, and motivate your request.</p>"},{"location":"adding_software/contribution_policy/#recent_software_versions","title":"vi) Recent software versions","text":"<p>We strongly prefer adding sufficiently recent software versions to EESSI.</p> <p>If you would like to add older software versions, please clearly motivate the need for this in your contribution.</p>"},{"location":"adding_software/contribution_policy/#cpu_targets","title":"vii) CPU targets","text":"<p>Software that is added to EESSI should work on all supported CPU targets.</p> <p>Exceptions to this requirement are allowed if technical problems that can not be resolved with reasonable effort prevent the installation of the software for specific CPU targets.</p>"},{"location":"adding_software/contribution_policy/#testing","title":"viii) Testing","text":"<p>We should be able to test the software installations via the EESSI test suite, in particular for software applications and user-facing tools.</p> <p>Ideally one or more tests are available that verify that the software is functionally correct, and that it (still) performs well.</p> <p>Tests that are run during the software installation procedure as performed by EasyBuild must pass. Exceptions can be made if only a small subset of tests fail for specific CPU targets, as long as these exceptions are tracked and an effort is made to assess the impact of those failing tests.</p> <p>It should be possible to run a minimal smoke test for the software included in EESSI, for example using EasyBuild's <code>--sanity-check-only</code> feature.</p> <p>Note</p> <p>The EESSI test suite is still in active development, and currently only has a minimal set of tests available.</p> <p>When the test suite is more mature, this requirement will be enforced more strictly.</p>"},{"location":"adding_software/contribution_policy/#changelog","title":"Changelog","text":""},{"location":"adding_software/contribution_policy/#v010-9-nov-2023","title":"v0.1.0 (9 Nov 2023)","text":"<ul> <li>initial contribution policy</li> </ul>"},{"location":"adding_software/debugging_failed_builds/","title":"Debugging failed builds","text":"<p>(for contributors + maintainers)</p> <p>Unfortunately, software does not always build successfully. Since EESSI targets novel CPU architectures as well, build failures on such platforms are quite common, as the software and/or the software build systems have not always been adjusted to support these architectures yet.</p> <p>In EESSI, all software packages are built by a bot. This is great for builds that complete successfully as we can build many software packages for a wide range of hardware with little human intervention. However, it does mean that you, as contributor, can not easily access the build directory and build logs to figure out build issues.</p> <p>This page describes how you can interactively reproduce failed builds, so that you can more easily debug the issue.</p> <p>Throughout this page, we will use this PR as an example. It intends to add LAMMPS to EESSI. Among other issues, it failed on a building Plumed.</p>"},{"location":"adding_software/debugging_failed_builds/#prerequisites","title":"Prerequisites","text":"<p>You will need to have:</p> <ul> <li>Access to a machine with the hardware for which the build that you want to debug failed. </li> <li>On that machine, meet the requirements for running the EESSI container, as described on this page.</li> </ul>"},{"location":"adding_software/debugging_failed_builds/#preparing-the-environment","title":"Preparing the environment","text":"<p>A number of steps are needed to create the same environment in which the bot builds.</p> <ul> <li>Fetching the feature branch from which you want to replicate a build.</li> <li>Starting a shell in the EESSI container.</li> <li>Start the Gentoo Prefix environment.</li> <li>Start the EESSI software environment.</li> <li>Configure EasyBuild.</li> </ul>"},{"location":"adding_software/debugging_failed_builds/#fetching-the-feature-branch","title":"Fetching the feature branch","text":"<p>Looking at the example PR, we see the PR is created from this fork. First, we clone the fork, then checkout the feature branch (<code>LAMMPS_23Jun2022</code>) <pre><code>git clone https://github.com/laraPPr/software-layer/\ncd software-layer\ngit checkout LAMMPS_23Jun2022\n</code></pre> Alternatively, if you already have a clone of the <code>software-layer</code> you can add it as a new remote <pre><code>cd software-layer\ngit remote add laraPPr https://github.com/laraPPr/software-layer/\ngit fetch laraPPr\ngit checkout LAMMPS_23Jun2022\n</code></pre></p>"},{"location":"adding_software/debugging_failed_builds/#starting-a-shell-in-the-eessi-container","title":"Starting a shell in the EESSI container","text":"<p>Simply run the EESSI container (<code>eessi_container.sh</code>), which should be in the root of the <code>software-layer</code> repository <pre><code>./eessi_container.sh --access rw\n</code></pre></p> <p>Note</p> <p>You may have to press enter to clearly see the prompt as some messages beginning with <code>CernVM-FS:</code> have been printed after the first prompt <code>Apptainer&gt;</code> was shown.</p> <p>If you want to debug an issue for which a lot of dependencies need to be build first, you may want to start the container with the <code>--save DIR/TGZ</code> and flag (check <code>./eessi_container.sh --help</code>). This saves the temporary directory (which we will use as working and installation directory later in this instruction) in order to be able to resume later with the same temporary directory. E.g.</p> <p><pre><code>./eessi_container.sh --access rw --save ${HOME}/pr370\n</code></pre> The tarball will be saved when you exit the container. Note that the first <code>exit</code> command will first make you exit the Gentoo prefix environment. Only the second will take you out of the container, and print where the tarball will be stored: <pre><code>[EESSI 2023.06] $ exit\nlogout\nLeaving Gentoo Prefix with exit status 1\nApptainer&gt; exit\nexit\nSaved contents of tmp directory '/tmp/eessi-debug.VgLf1v9gf0' to tarball '${HOME}/pr370/EESSI-1698056784.tgz' (to resume session add '--resume ${HOME}/pr370/EESSI-1698056784.tgz')\n</code></pre></p> <p>Note that the tarballs can be quite sizeable, so make sure to pick a filesystem where you have a large enough quotum.</p> <p>Next time you want to continue investigating this issue, you can start the container with <code>--resume DIR/TGZ</code> and continue where you left off, having all dependencies already built and available. <pre><code>./eessi_container.sh --access rw --resume ${HOME}/pr370/EESSI-1698056784.tgz\n</code></pre></p> <p>For a detailed description on using the script <code>eessi_container.sh</code>, see here.</p>"},{"location":"adding_software/debugging_failed_builds/#start-the-gentoo-prefix-environment","title":"Start the Gentoo Prefix environment","text":"<p>The next step is to start the Gentoo Prefix environment. </p> <p>Before we start, check the current values of <code>${EESSI_CVMFS_REPO}</code> and <code>${EESSI_VERSION}</code> so that you can reset them later: <pre><code>echo ${EESSI_CVMFS_REPO}\necho ${EESSI_VERSION}\n</code></pre></p> <p>Then, we set <code>EESSI_OS_TYPE</code> and <code>EESSI_CPU_FAMILY</code> and run the <code>startprefix</code> command to start the Gentoo Prefix environment: <pre><code>export EESSI_OS_TYPE=linux  # We only support Linux for now\nexport EESSI_CPU_FAMILY=$(uname -m)\n${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/compat/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/startprefix\n</code></pre></p> <p>Now, reset the <code>${EESSI_CVMFS_REPO}</code> and <code>${EESSI_VERSION}</code> in your prefix environment with the initial values (printed in the echo statements above) <pre><code>export EESSI_CVMFS_REPO=...\nexport EESSI_VERSION=...\n</code></pre></p> <p>Note</p> <p>By activating the Gentoo Prefix environment, the system tools (e.g. <code>ls</code>) you would normally use are now provided by Gentoo Prefix, instead of the container OS. E.g. running <code>which ls</code> after starting the prefix environment as above will return <code>/cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/bin/ls</code>. This makes the builds completely independent from the container OS.</p>"},{"location":"adding_software/debugging_failed_builds/#starting-the-eessi-software-environment","title":"Starting the EESSI software environment","text":"<p>Note</p> <p>If you want to replicate a build with <code>generic</code> optimization (i.e. in <code>$EESSI_CVMFS_REPO/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/generic</code>) you will need to set <code>export EESSI_SOFTWARE_SUBDIR_OVERRIDE=${EESSI_CPU_FAMILY}/generic</code> before starting the EESSI environment.</p> <p>To activate the software environment, run <pre><code>source ${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/init/bash\n</code></pre></p> <p>Note</p> <p>If you get an error <code>bash: /versions//init/bash: No such file or directory</code>, you forgot to reset the <code>${EESSI_CVFMS_REPO}</code> and <code>${EESSI_VERSION}</code> environment variables at the end of the previous step.</p> <p>Note</p> <p>If you want to build with generic optimization, you should run <code>export EESSI_CPU_FAMILY=$(uname -m) &amp;&amp; export EESSI_SOFTWARE_SUBDIR_OVERRIDE=${EESSI_CPU_FAMILY}/generic</code> before sourcing.</p> <p>For more info on starting the EESSI software environment, see here</p>"},{"location":"adding_software/debugging_failed_builds/#configure-easybuild","title":"Configure EasyBuild","text":"<p>It is important that we configure EasyBuild in the same way as the bot uses it, with one small exceptions: our working directory will be different. Typically, that doesn't matter, but it's good to be aware of this one difference, in case you fail to replicate the build failure.</p> <p>In this example, we create a unique temporary directory inside <code>/tmp</code> to serve both as our workdir. Finally, we will source the <code>configure_easybuild</code> script, which will configure EasyBuild by setting environment variables.</p> <p><pre><code>export WORKDIR=$(mktemp --directory --tmpdir=/tmp  -t eessi-debug.XXXXXXXXXX)\nsource configure_easybuild\n</code></pre> Among other things, the <code>configure_easybuild</code> script sets the install path for EasyBuild to point to the correct installation directory in (to <code>${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_SOFTWARE_SUBDIR}</code>). This is the exact same path the <code>bot</code> uses to build, and uses a writeable overlay filesystem in the container to write to a path in <code>/cvmfs</code> (which normally is read-only). This is identical to what the <code>bot</code> does.</p> <p>Note</p> <p>If you started the container using --resume, you may want WORKDIR to point to the workdir you created previously (instead of creating a new, temporary directory with <code>mktemp</code>).</p> <p>Note</p> <p>If you want to replicate a build with <code>generic</code> optimization (i.e. in <code>$EESSI_CVMFS_REPO/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/generic</code>) you will need to set <code>export EASYBUILD_OPTARCH=GENERIC</code> after sourcing <code>configure_easybuild</code>.</p> <p>Next, we need to determine the correct version of EasyBuild to load. Since the example PR changes the file <code>eessi-2023.06-eb-4.8.1-2021b.yml</code>, this tells us the bot was using version <code>4.8.1</code> of EasyBuild to build this. Thus, we load that version of the EasyBuild module and check if everything was configured correctly: <pre><code>module load EasyBuild/4.8.1\neb --show-config\n</code></pre> You should get something similar to</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/easybuild/easybuild/build\ncontainerpath        (E) = /tmp/easybuild/easybuild/containers\ndebug                (E) = True\nexperimental         (E) = True\nfilter-deps          (E) = Autoconf, Automake, Autotools, binutils, bzip2, DBus, flex, gettext, gperf, help2man, intltool, libreadline, libtool, Lua, M4, makeinfo, ncurses, util-linux, XZ, zlib, Yasm\nfilter-env-vars      (E) = LD_LIBRARY_PATH\nhooks                (E) = ${HOME}/software-layer/eb_hooks.py\nignore-osdeps        (E) = True\ninstallpath          (E) = /tmp/easybuild/software/linux/aarch64/neoverse_n1\nmodule-extensions    (E) = True\npackagepath          (E) = /tmp/easybuild/easybuild/packages\nprefix               (E) = /tmp/easybuild/easybuild\nread-only-installdir (E) = True\nrepositorypath       (E) = /tmp/easybuild/easybuild/ebfiles_repo\nrobot-paths          (D) = /cvmfs/software.eessi.io/versions/2023.06/software/linux/aarch64/neoverse_n1/software/EasyBuild/4.8.1/easybuild/easyconfigs\nrpath                (E) = True\nsourcepath           (E) = /tmp/easybuild/easybuild/sources:\nsysroot              (E) = /cvmfs/software.eessi.io/versions/2023.06/compat/linux/aarch64\ntrace                (E) = True\nzip-logs             (E) = bzip2\n</code></pre>"},{"location":"adding_software/debugging_failed_builds/#building-the-software","title":"Building the software","text":"<p>When the bot builds software, it loops over all EasyStack files that have been changed, and builds them using EasyBuild. However, a single PR may add multiple items to a single EasyStack file, and the issue you are trying to debug is probably in one of them. Getting EasyBuild to build the full EasyStack file will create the most similar situation to what the bot does. However, you may just want to build the individual software that has changed. Below, we describe both approaches.</p>"},{"location":"adding_software/debugging_failed_builds/#building-everything-in-the-easystack-file","title":"Building everything in the EasyStack file","text":"<p>In our example PR, the EasyStack file that was changed was <code>eessi-2023.06-eb-4.8.1-2021b.yml</code>. To build this, we run (in the directory that contains the checkout of this feature branch): <pre><code>eb --easystack eessi-2023.06-eb-4.8.1-2021b.yml --robot\n</code></pre> After some time, this build fails while trying to build <code>Plumed</code>, and we can access the build log to look for clues on why it failed.</p>"},{"location":"adding_software/debugging_failed_builds/#building-an-individual-package","title":"Building an individual package","text":"<p>In our example PR, the individual package that was added to <code>eessi-2023.06-eb-4.8.1-2021b.yml</code> was <code>LAMMPS-23Jun2022-foss-2021b-kokkos.eb</code>. We'll also have to (re)use any options that are listed in the EasyStack file for <code>LAMMPS-23Jun2022-foss-2021b-kokkos.eb</code>, in this case the option <code>--from-pr 19000</code>. Thus, to build, we run: <pre><code>eb LAMMPS-23Jun2022-foss-2021b-kokkos.eb --robot --from-pr 19000\n</code></pre> After some time, this build fails while trying to build <code>Plumed</code>, and we can access the build log to look for clues on why it failed.</p> <p>Note</p> <p>While this might be faster than the EasyStack-based approach, this is not how the bot builds. So why it may reproduce the failure the bot encounters, it may not reproduce the bug at all (no failure) or run into different bugs. If you want to be sure, use the EasyStack-based approach.</p>"},{"location":"adding_software/debugging_failed_builds/#known-causes-of-issues-in-eessi","title":"Known causes of issues in EESSI","text":""},{"location":"adding_software/debugging_failed_builds/#the-custom-system-prefix-of-the-compatibility-layer","title":"The custom system prefix of the compatibility layer","text":"<p>Some installations might expect the system root (sysroot, for short) to be in <code>/</code>. However, in case of EESSI, we are building against the OS in the compatibility layer. Thus, our sysroot is something like <code>${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/compat/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}</code>. This can cause issues if installation procedures assume the sysroot is in <code>/</code>.</p> <p>One example of a sysroot issue was in installing <code>wget</code>. The EasyConfig for <code>wget</code> defined <pre><code># make sure pkg-config picks up system packages (OpenSSL &amp; co)\npreconfigopts = \"export PKG_CONFIG_PATH=/usr/lib64/pkgconfig:/usr/lib/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig &amp;&amp; \"\nconfigopts = '--with-ssl=openssl '\n</code></pre> This will not work in EESSI, since the OpenSSL should be picked up from the compatibility layer. This was fixed by changing the EasyConfig to read <pre><code>preconfigopts = \"export PKG_CONFIG_PATH=%(sysroot)s/usr/lib64/pkgconfig:%(sysroot)s/usr/lib/pkgconfig:%(sysroot)s/usr/lib/x86_64-linux-gnu/pkgconfig &amp;&amp; \"\nconfigopts = '--with-ssl=openssl\n</code></pre> The <code>%(sysroot)s</code> is a template value which EasyBuild will resolve to the value that has been configured in EasyBuild for <code>sysroot</code> (it is one of the fields printed by <code>eb --show-config</code> if a non-standard sysroot is configured).</p> <p>If you encounter issues where the installation can not find something that is normally provided by the OS (i.e. not one of the dependencies in your module environment), you may need to resort to a similar approach.</p>"},{"location":"adding_software/debugging_failed_builds/#the-writeable-overlay","title":"The writeable overlay","text":"<p>The writeable overlay in the container is known to be a bit slow sometimes. Thus, we have seen tests failing because they exceed some timeout (e.g. this issue).</p> <p>To investigate if the writeable overlay is somehow the issue, you can make sure the installation gets done somewhere else, e.g. in the temporary directory in <code>/tmp</code> that you created as workdir. To do this, set</p> <pre><code>export EASYBUILD_INSTALLPATH=${WORKDIR}\n</code></pre> <p>after the step in which you have sourced the <code>configure_easybuild</code> script. Note that in order to find (with <code>module av</code>) any modules that get installed here, you will need to add this path to the <code>MODULEPATH</code>:</p> <pre><code>module use ${EASYBUILD_INSTALLPATH}/modules/all\n</code></pre> <p>Then, retry building the software (as described above). If the build now succeeds, you know that indeed the writeable overlay caused the issue. We have to build in this writeable overlay when we do real deployments. Thus, if you hit such a timeout, try to see if you can (temporarily) modify the timeout value in the test so that it passes.</p>"},{"location":"adding_software/deploying_software/","title":"Deploying software","text":"<p>(for maintainers)</p>"},{"location":"adding_software/deploying_software/#instructing-the-bot-to-deploy","title":"Instructing the bot to deploy","text":"<p>To make the bot  deploy the successfully built software, you should issue the corresponding instruction to the bot.</p> <p>For more information, see the deploying section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger deployment of software installations must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/deploying_software/#merging-the-pull-request","title":"Merging the pull request","text":"<p>You should be able to verify in the pull request that the ingestion has been done, since the CI should fail  initially to indicate that some software installations listed in your modified easystack are missing.</p> <p>Once the ingestion has been done, simply re-triggering the CI workflow should be sufficient to make it pass , and then the pull request can be merged.</p> <p>Note</p> <p>This assumes that the easystack file being modified is considered by the CI workflow file (<code>.github/workflows/test_eessi.yml</code>) that checks for missing installations, in the correct branch (for example <code>2023.06</code>) of the software-layer.</p> <p>If that's not the case yet, update this workflow in your pull request as well to add the missing easystack file!</p> <p>Warning</p> <p>You need permissions to re-trigger CI workflows and merge pull requests in the software-layer repository.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/deploying_software/#getting-help","title":"Getting help","text":"<p>If you have any questions, or if you need help with something, don't hesitate to contact us via the <code>#software-layer</code> channel of the EESSI Slack.</p>"},{"location":"adding_software/opening_pr/","title":"Opening a pull request","text":"<p>(for contributors)</p> <p>To add software to EESSI, you should go through the semi-automatic software installation procedure by:</p> <ul> <li>1) Making a pull request to the software-layer repository      to (add or) update an easystack file  that is used by      EasyBuild to install software;</li> <li>2) Instructing the bot  to build the software on all supported CPU microarchitectures;</li> <li>3) Instructing the bot  to deploy the built software for ingestion into the EESSI repository;</li> <li>4) Merging the pull request once CI indicates that the software has been ingested. </li> </ul> <p>Warning</p> <p>Make sure you are also aware of our contribution policy when adding software to EESSI.</p>"},{"location":"adding_software/opening_pr/#preparation","title":"Preparation","text":"<p>Before you can make a pull request to the software-layer, you should fork the repository in your GitHub account.</p> <p>For the remainder of these instructions, we assume that your GitHub account is <code>@koala</code> .</p> <p>Note</p> <p>Don't forget to replace <code>koala</code>  with the name of your GitHub account in the commands below!</p> <p>1) Clone the EESSI/software-layer repository:</p> <pre><code>mkdir EESSI\ncd EESSI\ngit clone https://github.com/EESSI/software-layer\ncd software-layer\n</code></pre> <p>2) Add your fork  as a remote</p> <pre><code>git remote add koala git@github.com:koala/software-layer.git\n</code></pre> <p>3) Check out the branch that corresponds to the version of EESSI repository you want to add software to,    for example <code>2023.06-software.eessi.io</code>:</p> <pre><code>git checkout 2023.06-software.eessi.io\n</code></pre> <p>Note</p> <p>The commands above only need to be run once, to prepare your setup for making pull requests.</p>"},{"location":"adding_software/opening_pr/#software_layer_pull_request","title":"Creating a pull request","text":"<p>1) Make sure that your <code>2023.06-software.eessi.io</code> branch in the checkout of the   <code>EESSI/software-layer</code> repository is up-to-date</p> <pre><code>cd EESSI/software-layer\ngit checkout 2023.06-software.eessi.io \ngit pull origin 2023.06-software.eessi.io \n</code></pre> <p>2) Create a new branch (use a sensible name, not <code>example_branch</code> as below), and check it out</p> <pre><code>git checkout -b example_branch\n</code></pre> <p>3) Determine the correct easystack file to change, and add one or more lines to it that specify which    easyconfigs should be installed</p> <pre><code>echo '  - example-1.2.3-GCC-12.3.0.eb' &gt;&gt; easystacks/software.eessi.io/2023.06/eessi-2023.06-eb-4.8.2-2023a.yml\n</code></pre> <p>4) Stage and commit the changes into your your branch with a sensible message</p> <pre><code>git add easystacks/software.eessi.io/2023.06/eessi-2023.06-eb-4.8.2-2023a.yml\ngit commit -m \"{2023.06}[GCC/12.3.0] example 1.2.3\"\n</code></pre> <p>5) Push your branch to your fork  of the software-layer repository</p> <pre><code>git push koala example_branch\n</code></pre> <p>6) Go to the GitHub web interface to open your pull request,    or use the helpful link that should show up in the output of the <code>git push</code> command.</p> <p>Make sure you target the correct branch: the one that corresponds to the version of EESSI you want to add    software to (like <code>2023.06-software.eessi.io</code>).</p> <p>If all goes well, one or more bots  should almost instantly create a comment in your pull request    with an overview of how it is configured - you will need this information when providing build instructions.</p>"},{"location":"adding_software/overview/","title":"Overview of adding software to EESSI","text":"<p>We welcome contributions to the EESSI software stack. This page shows the procedure and provides links to the contribution policy and the technical details of making a contribution. </p>"},{"location":"adding_software/overview/#contribute-a-software-to-the-eessi-software-stack","title":"Contribute a software to the EESSI software stack","text":""},{"location":"adding_software/overview/#contributing-a-reframe-test-to-the-eessi-test-suite","title":"Contributing a ReFrame test to the EESSI test suite","text":"<p>Ideally, a contributor prepares a ReFrame test for the software to be added to the EESSI software stack. </p> <p> </p>"},{"location":"adding_software/overview/#more-about-adding-software-to-eessi","title":"More about adding software to EESSI","text":"<ul> <li>Contribution policy</li> <li>Opening a pull request (for contributors)</li> <li>Building software (for maintainers)</li> <li>Debugging failed builds (for contributors + maintainers)</li> <li>Deploying software (for maintainers)</li> </ul> <p>If you need help with adding software to EESSI, please open a support request.</p>"},{"location":"filesystem_layer/stratum1/","title":"Setting up a Stratum 1","text":"<p>Setting up a Stratum 1 involves the following steps:</p> <ul> <li>set up the Stratum 1, preferably by running the Ansible playbook that we provide;</li> <li>request a Stratum 0 firewall exception for your Stratum 1 server;</li> <li>request a <code>&lt;your site&gt;.stratum1.cvmfs.eessi-infra.org</code> DNS entry;</li> <li>open a pull request to include the URL to your Stratum 1 in the EESSI configuration.</li> </ul> <p>The last two steps can be skipped if you want to host a \"private\" Stratum 1 for your site.</p>"},{"location":"filesystem_layer/stratum1/#requirements-for-a-stratum-1","title":"Requirements for a Stratum 1","text":"<p>The main requirements for a Stratum 1 server are a good network connection to the clients it is going to serve, and sufficient disk space. For the EESSI repository, a few hundred gigabytes should suffice, but for production environments at least 1 TB would be recommended.</p> <p>In terms of cores and memory, a machine with just a few (~4) cores and 4-8 GB of memory should suffice.</p> <p>Various Linux distributions are supported, but we recommend one based on RHEL 7 or 8.</p> <p>Finally, make sure that ports 80 (for the Apache web server) and 8000 are open.</p>"},{"location":"filesystem_layer/stratum1/#step-1-set-up-the-stratum-1","title":"Step 1: set up the Stratum 1","text":"<p>The recommended way for setting up an EESSI Stratum 1 is by running the Ansible playbook <code>stratum1.yml</code> from the filesystem-layer repository on GitHub.</p> <p>Installing a Stratum 1 requires a GEO API license key, which will be used to find the (geographically) closest Stratum 1 server for your client and proxies. More information on how to (freely) obtain this key is available in the CVMFS documentation: https://cvmfs.readthedocs.io/en/stable/cpt-replica.html#geo-api-setup.</p> <p>You can put your license key in the local configuration file <code>inventory/local_site_specific_vars.yml</code>.</p> <p>Furthermore, the Stratum 1 runs a Squid server. The template configuration file can be found at <code>templates/eessi_stratum1_squid.conf.j2</code>. If you want to customize it, for instance for limiting the access to the Stratum 1, you can make your own version of this template file  and point to it by setting <code>local_stratum1_cvmfs_squid_conf_src</code> in <code>inventory/local_site_specific_vars.yml</code>. See the comments in the example file for more details.</p> <p>Start by installing Ansible:</p> <pre><code>sudo yum install -y ansible\n</code></pre> <p>Then install Ansible roles for EESSI:</p> <pre><code>ansible-galaxy role install -r requirements.yml -p ./roles --force\n</code></pre> <p>Make sure you have enough space in <code>/srv</code> (on the Stratum 1) since the snapshot of the Stratum 0 will end up there by default. To alter the directory where the snapshot gets copied to you can add this variable in <code>inventory/host_vars/&lt;url-or-ip-to-your-stratum1&gt;</code>:</p> <pre><code>cvmfs_srv_mount: /srv\n</code></pre> <p>Make sure that you have added the hostname or IP address of your server to the <code>inventory/hosts</code> file. Finally, install the Stratum 1 using one of the two following options.</p> <p>Option 1:</p> <pre><code># -b to run as root, optionally use -K if a sudo password is required\nansible-playbook -b [-K] -e @inventory/local_site_specific_vars.yml stratum1.yml\n</code></pre> <p>Option2:</p> <p>Create a ssh key pair and make sure the <code>ansible-host-keys.pub</code> is in the <code>$HOME/.ssh/authorized_keys</code> file on your Stratum 1 server.</p> <pre><code>ssh-keygen -b 2048 -t rsa -f ~/.ssh/ansible-host-keys -q -N \"\"\n</code></pre> <p>Then run the playbook:</p> <pre><code>ansible-playbook -b --private-key ~/.ssh/ansible-host-keys -e @inventory/local_site_specific_vars.yml stratum1.yml\n</code></pre> <p>Running the playbook will automatically make replicas of all the repositories defined in <code>group_vars/all.yml</code>.</p>"},{"location":"filesystem_layer/stratum1/#step-2-request-a-firewall-exception","title":"Step 2: request a firewall exception","text":"<p>(This step is not implemented yet and can be skipped)</p> <p>You can request a firewall exception rule to be added for your Stratum 1 server by opening an issue on the GitHub page of the filesystem layer repository.</p> <p>Make sure to include the IP address of your server.</p>"},{"location":"filesystem_layer/stratum1/#step-3-verification-of-the-stratum-1","title":"Step 3: Verification of the Stratum 1","text":"<p>When the playbook has finished your Stratum 1 should be ready. In order to test your Stratum 1, even without a client installed, you can use <code>curl</code>.</p> <p><pre><code>curl --head http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> This should return:</p> <pre><code>HTTP/1.1 200 OK\n...\nX-Cache: MISS from &lt;url-or-ip-to-your-stratum1&gt;\n</code></pre> <p>The second time you run it, you should get a cache hit:</p> <pre><code>X-Cache: HIT from &lt;url-or-ip-to-your-stratum1&gt;\n</code></pre> <p>Example with the Norwegian Stratum 1:</p> <pre><code>curl --head http://bgo-no.stratum1.cvmfs.eessi-infra.org/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> <p>You can also test access to your Stratum 1 from a client, for which you will have to install the CVMFS client. </p> <p>Then run the following command to add your newly created Stratum 1 to the existing list of EESSI Stratum 1 servers by creating a local CVMFS configuration file:</p> <pre><code>echo 'CVMFS_SERVER_URL=\"http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/@fqrn@;$CVMFS_SERVER_URL\"' | sudo tee -a /etc/cvmfs/domain.d/eessi-hpc.org.local\n</code></pre> <p>If this is the first time you set up the client you now run:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> <p>If you already had configured the client before, you can simply reload the config:</p> <pre><code>sudo cvmfs_config reload -c software.eessi.io\n</code></pre> <p>Finally, verify that the client connects to your new Stratum 1 by running:</p> <pre><code>cvmfs_config stat -v software.eessi.io\n</code></pre> <p>Assuming that your new Stratum 1 is the geographically closest one to your client, this should return:</p> <pre><code>Connection: http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/software.eessi.io through proxy DIRECT (online)\n</code></pre>"},{"location":"filesystem_layer/stratum1/#step-4-request-an-eessi-dns-name","title":"Step 4: request an EESSI DNS name","text":"<p>In order to keep the configuration clean and easy, all the EESSI Stratum 1 servers have a DNS name <code>&lt;your site&gt;.stratum1.cvmfs.eessi-infra.org</code>, where <code>&lt;your site&gt;</code> is often a short name or abbreviation followed by the country code (e.g. <code>rug-nl</code> or <code>bgo-no</code>).  You can request this for your Stratum 1 by mentioning this in the issue that you created in Step 2, or by opening another issue.</p>"},{"location":"filesystem_layer/stratum1/#step-5-include-your-stratum-1-in-the-eessi-configuration","title":"Step 5: include your Stratum 1 in the EESSI configuration","text":"<p>If you want to include your Stratum 1 in the EESSI configuration, i.e. allow any (nearby) client to be able to use it, you can open a pull request with updated configuration files. You will only have to add the URL to your Stratum 1 to the  <code>urls</code> list of the <code>eessi_cvmfs_server_urls</code> variable in the <code>all.yml</code> file.</p>"},{"location":"getting_access/eessi_container/","title":"EESSI container","text":"<p>The <code>eessi_container.sh</code> script provides a very easy yet versatile means to access EESSI.</p> <p>This page guides you through several example scenarios illustrating the use of the script.</p>"},{"location":"getting_access/eessi_container/#prerequisites","title":"Prerequisites","text":"<ul> <li>Apptainer 1.0.0 (or newer), or Singularity 3.7.x<ul> <li>Check with <code>apptainer --version</code> or <code>singularity --version</code></li> <li>Support for the <code>--fusemount</code> option in the <code>shell</code> and <code>run</code> subcommands is required</li> </ul> </li> <li>Git<ul> <li>Check with <code>git --version</code></li> </ul> </li> </ul>"},{"location":"getting_access/eessi_container/#preparation","title":"Preparation","text":"<p>Clone the <code>EESSI/software-layer</code> repository and change into the <code>software-layer</code> directory by running these commands:</p> <pre><code>git clone https://github.com/EESSI/software-layer.git\ncd software-layer\n</code></pre>"},{"location":"getting_access/eessi_container/#quickstart","title":"Quickstart","text":"<p>Run the <code>eessi_container</code> script (from the <code>software-layer</code> directory) to start a shell session in the EESSI container:</p> <pre><code>./eessi_container.sh\n</code></pre> <p>Note</p> <p>Startup will take a bit longer the first time you run this because the container image is downloaded and converted.</p> <p>You should see output like <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell  --fusemount container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.ymYGaZwoWC/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nApptainer&gt; CernVM-FS: loading Fuse module... done\nCernVM-FS: loading Fuse module... done\n\nApptainer&gt;\n</code></pre></p> <p>Note</p> <p>You may have to press enter to clearly see the prompt as some messages beginning with <code>CernVM-FS:</code> have been printed after the first prompt <code>Apptainer&gt;</code> was shown.</p> <p>To start using EESSI, see Using EESSI/Setting up your environment.</p>"},{"location":"getting_access/eessi_container/#help-for-eessi_containersh","title":"Help for <code>eessi_container.sh</code>","text":"<p>The example in the Quickstart section facilitates an interactive session with read access to the EESSI software stack. It does not require any command line options, because the script <code>eessi_container.sh</code> uses some carefully chosen defaults. To view all options of the script and its default values, run the command <pre><code>./eessi_container.sh --help\n</code></pre> You should see the following output <pre><code>usage: ./eessi_container.sh [OPTIONS] [[--] SCRIPT or COMMAND]\n OPTIONS:\n  -a | --access {ro,rw}  - ro (read-only), rw (read &amp; write) [default: ro]\n  -c | --container IMG   - image file or URL defining the container to use\n                           [default: docker://ghcr.io/eessi/build-node:debian11]\n  -g | --storage DIR     - directory space on host machine (used for\n                           temporary data) [default: 1. TMPDIR, 2. /tmp]\n  -h | --help            - display this usage information [default: false]\n  -i | --host-injections - directory to link to for host_injections \n                           [default: /..storage../opt-eessi]\n  -l | --list-repos      - list available repository identifiers [default: false]\n  -m | --mode MODE       - with MODE==shell (launch interactive shell) or\n                           MODE==run (run a script or command) [default: shell]\n  -n | --nvidia MODE     - configure the container to work with NVIDIA GPUs,\n                           MODE==install for a CUDA installation, MODE==run to\n                           attach a GPU, MODE==all for both [default: false]\n  -r | --repository CFG  - configuration file or identifier defining the\n                           repository to use [default: EESSI via\n                           container configuration]\n  -u | --resume DIR/TGZ  - resume a previous run from a directory or tarball,\n                           where DIR points to a previously used tmp directory\n                           (check for output 'Using DIR as tmp ...' of a previous\n                           run) and TGZ is the path to a tarball which is\n                           unpacked the tmp dir stored on the local storage space\n                           (see option --storage above) [default: not set]\n  -s | --save DIR/TGZ    - save contents of tmp directory to a tarball in\n                           directory DIR or provided with the fixed full path TGZ\n                           when a directory is provided, the format of the\n                           tarball's name will be {REPO_ID}-{TIMESTAMP}.tgz\n                           [default: not set]\n  -v | --verbose         - display more information [default: false]\n  -x | --http-proxy URL  - provides URL for the env variable http_proxy\n                           [default: not set]; uses env var $http_proxy if set\n  -y | --https-proxy URL - provides URL for the env variable https_proxy\n                           [default: not set]; uses env var $https_proxy if set\n\n If value for --mode is 'run', the SCRIPT/COMMAND provided is executed. If\n arguments to the script/command start with '-' or '--', use the flag terminator\n '--' to let eessi_container.sh stop parsing arguments.\n</code></pre></p> <p>So, the defaults are equal to running the command <pre><code>./eessi_container.sh --access ro --container docker://ghcr.io/eessi/build-node:debian11 --mode shell --repository EESSI\n</code></pre> and it would either create a temporary directory under <code>${TMPDIR}</code> (if defined), or <code>/tmp</code> (if <code>${TMPDIR}</code> is not defined).</p> <p>The remainder of this page will demonstrate different scenarios using some of the command line options used for read-only access.</p> <p>Other options supported by the script will be discussed in a yet-to-be written section covering building software to be added to the EESSI stack.</p>"},{"location":"getting_access/eessi_container/#resuming-a-previous-session","title":"Resuming a previous session","text":"<p>You may have noted the following line in the output of <code>eessi_container.sh</code> <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).\n</code></pre></p> <p>Note</p> <p>The parameter after <code>--resume</code> (<code>/tmp/eessi.abc123defg</code>) will be different when you run <code>eessi_container.sh</code>.</p> <p>Scroll back in your terminal and copy it so you can pass it to <code>--resume</code>.</p> <p>Try the following command to \"resume\" from the last session. <pre><code>./eessi_container.sh --resume /tmp/eessi.abc123defg\n</code></pre> This should run much faster because the container image has been cached in the temporary directory (<code>/tmp/eessi.abc123defg</code>). You should get to the prompt (<code>Apptainer&gt;</code> or <code>Singularity&gt;</code>) and can use EESSI with the state where you left the previous session.</p> <p>Note</p> <p>The state refers to what was stored on disk, not what was changed in memory. Particularly, any environment (variable) settings are not restored automatically.</p> <p>Because the <code>/tmp/eessi.abc123defg</code> directory contains a <code>home</code> directory which includes the saved history of your last session, you can easily restore the environment (variable) settings. Type <code>history</code> to see which commands you ran. You should be able to access the history as you would do in a normal terminal session.</p>"},{"location":"getting_access/eessi_container/#running-a-simple-command","title":"Running a simple command","text":"<p>Let's \"<code>ls /cvmfs/software.eessi.io</code>\" through the <code>eessi_container.sh</code> script to check if the CernVM-FS EESSI repository is accessible:</p> <pre><code>./eessi_container.sh --mode run ls /cvmfs/software.eessi.io\n</code></pre> <p>You should see an output such as</p> <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).$\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell  --fusemount container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.ymYGaZwoWC/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nhost_injections  latest  versions\n</code></pre> <p>Note that this time no interactive shell session is started in the container: only the provided command is run in the container, and when that finishes you are back in the shell session where you ran the <code>eessi_container.sh</code> script.</p> <p>This is because we used the <code>--mode run</code> command line option.</p> <p>Note</p> <p>The last line in the output is the output of the <code>ls</code> command, which shows the contents of the <code>/cvmfs/software.eessi.io</code> directory.</p> <p>Also, note that there is no shell prompt (<code>Apptainer&gt;</code> or <code>Singularity</code>), since no interactive shell session is started in the container.</p> <p>Alternatively to specify the command as we did above, you can also do the following. <pre><code>CMD=\"ls -l /cvmfs/software.eessi.io\"\n./eessi_container.sh --mode shell &lt;&lt;&lt; ${CMD}\n</code></pre></p> <p>Note</p> <p>We changed the mode from <code>run</code> to <code>shell</code> because we use a different method to let the script run our command, by feeding it in via the <code>stdin</code> input channel using <code>&lt;&lt;&lt;</code>.</p> <p>Because <code>shell</code> is the default value for <code>--mode</code> we can also omit this and simply run <pre><code>CMD=\"ls -l /cvmfs/software.eessi.io\"\n./eessi_container.sh &lt;&lt;&lt; ${CMD}\n</code></pre></p>"},{"location":"getting_access/eessi_container/#running-a-script","title":"Running a script","text":"<p>While running simple command can be sufficient in some cases, you often want to run scripts containing multiple commands.</p> <p>Let's run the script shown below.</p> <p>First, copy-paste the contents for the script shown below, and create a file named <code>eessi_architectures.sh</code> in your current directory. Also make the script executable, by running:</p> <pre><code>chmod +x eessi_architectures.sh\n</code></pre> <p>Here are the contents for the <code>eessi_architectures.sh</code> script:</p> <p><pre><code>#!/usr/bin/env bash\n#\n# This script determines which architectures are included in the\n# latest EESSI version. It makes use of the specific directory\n# structure in the EESSI repository.\n#\n\n# determine list of available OS types\nBASE=${EESSI_CVMFS_REPO:-/cvmfs/software.eessi.io}/latest/software\ncd ${BASE}\nfor os_type in $(ls -d *)\ndo\n    # determine architecture families\n    OS_BASE=${BASE}/${os_type}\n    cd ${OS_BASE}\n    for arch_family in $(ls -d *)\n    do\n        # determine CPU microarchitectures\n        OS_ARCH_BASE=${BASE}/${os_type}/${arch_family}\n        cd ${OS_ARCH_BASE}\n        for microarch in $(ls -d *)\n        do\n            case ${microarch} in\n                amd | intel )\n                    for sub in $(ls ${microarch})\n                    do\n                        echo \"${os_type}/${arch_family}/${microarch}/${sub}\"\n                    done\n                    ;;\n                * )\n                    echo \"${os_type}/${arch_family}/${microarch}\"\n                    ;;\n            esac\n        done\n    done\ndone\n</code></pre> Run the script as follows <pre><code>./eessi_container.sh --mode shell &lt; eessi_architectures.sh\n</code></pre> The output should be similar to <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).$\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nlinux/aarch64/generic\nlinux/aarch64/graviton2\nlinux/aarch64/graviton3\nlinux/ppc64le/generic\nlinux/ppc64le/power9le\nlinux/x86_64/amd/zen2\nlinux/x86_64/amd/zen3\nlinux/x86_64/generic\nlinux/x86_64/intel/haswell\nlinux/x86_64/intel/skylake_avx512\n</code></pre> Lines 6 to 15 show the output of the script <code>eessi_architectures.sh</code>.</p> <p>If you want to use the mode <code>run</code>, you have to make the script's location available inside the container.</p> <p>This can be done by mapping the current directory (<code>${PWD}</code>), which contains <code>eessi_architectures.sh</code>, to any not-yet existing directory inside the container using the <code>$SINGULARITY_BIND</code> or <code>$APPTAINER_BIND</code> environment variable.</p> <p>For example: <pre><code>SINGULARITY_BIND=${PWD}:/scripts ./eessi_container.sh --mode run /scripts/eessi_architectures.sh\n</code></pre></p>"},{"location":"getting_access/eessi_container/#running-scripts-or-commands-with-parameters-starting-with-or-","title":"Running scripts or commands with parameters starting with <code>-</code> or <code>--</code>","text":"<p>Let's assume we would like to get more information about the entries of <code>/cvmfs/software.eessi.io</code>. If we would just run <pre><code>./eessi_container.sh --mode run ls -lH /cvmfs/software.eessi.io\n</code></pre> we would get an error message such as <pre><code>ERROR: Unknown option: -lH\n</code></pre> We can resolve this in two ways:</p> <ol> <li>Using the <code>stdin</code> channel as described above, for example, by simply running   <pre><code>CMD=\"ls -lH /cvmfs/software.eessi.io\"\n./eessi_container.sh &lt;&lt;&lt; ${CMD}\n</code></pre>   which should result in the output similar to   <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\ntotal 10\nlrwxrwxrwx 1 user user   10 Jun 30  2021 host_injections -&gt; /opt/eessi\nlrwxrwxrwx 1 user user   16 May  4  2022 latest -&gt; versions/2021.12\ndrwxr-xr-x 3 user user 4096 Dec 10  2021 versions\n</code></pre></li> <li>Using the flag terminator <code>--</code> which tells <code>eessi_container.sh</code> to stop parsing command line arguments. For example,   <pre><code>./eessi_container.sh --mode run -- ls -lH /cvmfs/software.eessi.io\n</code></pre>   which should result in the output similar to   <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q run --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif ls -lH /cvmfs/software.eessi.io\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\ntotal 10\nlrwxrwxrwx 1 user user   10 Jun 30  2021 host_injections -&gt; /opt/eessi\nlrwxrwxrwx 1 user user   16 May  4  2022 latest -&gt; versions/2021.12\ndrwxr-xr-x 3 user user 4096 Dec 10  2021 versions\n</code></pre></li> </ol>"},{"location":"getting_access/eessi_container/#running-eessi-demos","title":"Running EESSI demos","text":"<p>For examples of scripts that use the software provided by EESSI, see Running EESSI demos.</p>"},{"location":"getting_access/eessi_container/#launching-containers-more-quickly","title":"Launching containers more quickly","text":"<p>Subsequent runs of <code>eessi_container.sh</code> may reuse temporary data of a previous session, which includes the pulled image of the container. However, that is not always what we want, i.e., reusing a previous session (and thereby launching the container more quickly).</p> <p>The <code>eessi_container.sh</code> script may (re)-use a cache directory provided via <code>$SINGULARITY_CACHEDIR</code> (or <code>$APPTAINER_CACHEDIR</code> when using Apptainer). Hence, the container image does not have to be downloaded again even when starting a new session. The example below illustrates this. <pre><code>export SINGULARITY_CACHEDIR=${PWD}/container_cache_dir\ntime ./eessi_container.sh &lt;&lt;&lt; \"ls /cvmfs/software.eessi.io\"\n</code></pre> which should produce output similar to <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\nhost_injections  latest  versions\n\nreal    m40.445s\nuser    3m2.621s\nsys     0m7.402s\n</code></pre> The next run using the same cache directory, e.g., by simply executing <pre><code>time ./eessi_container.sh &lt;&lt;&lt; \"ls /cvmfs/software.eessi.io\"\n</code></pre> is much faster <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\nhost_injections  latest  versions\n\nreal    0m2.781s\nuser    0m0.172s\nsys     0m0.436s\n</code></pre></p> <p>Note</p> <p>Each run of <code>eessi_container.sh</code> (without specifying <code>--resume</code>) creates a new temporary directory. The temporary directory stores, among other data, the image file of the container. Thus we can ensure that the container is available locally for a subsequent run.</p> <p>However, this may quickly consume scarce resources, for example, a small partition where <code>/tmp</code> is located (default for temporary storage, see <code>--help</code> for specifying a different location).</p> <p>See next section for making sure to clean up no longer needed temporary data.</p>"},{"location":"getting_access/eessi_container/#reducing-disk-usage","title":"Reducing disk usage","text":"<p>By default <code>eessi_container.sh</code> creates a temporary directory under <code>/tmp</code>. The directories are named <code>eessi.RANDOM</code> where <code>RANDOM</code> is a 10-character string. The script does not automatically remove these directories. To determine their total disk usage, simply run <pre><code>du -sch /tmp/eessi.*\n</code></pre> which could result in output similar to <pre><code>333M    /tmp/eessi.session123\n333M    /tmp/eessi.session456\n333M    /tmp/eessi.session789\n997M    total\n</code></pre> Clean up disk usage by simply removing directories you do not need any longer.</p>"},{"location":"getting_access/is_eessi_accessible/","title":"Is EESSI accessible?","text":"<p>EESSI can be accessed via a native (CernVM-FS) installation, or via a container that includes CernVM-FS.</p> <p>Before you look into these options, check if EESSI is already accessible on your system.</p> <p>Run the following command: <pre><code>ls /cvmfs/software.eessi.io\n</code></pre></p> <p>Note</p> <p>This <code>ls</code> command may take a couple of seconds to finish, since CernVM-FS may need to download or update the metadata for that directory.</p> <p>If you see output like shown below, you already have access to EESSI on your system.  <pre><code>host_injections  latest  versions\n</code></pre></p> <p>For starting to use EESSI, continue reading about Setting up environment.</p> <p>If you see an error message as shown below, EESSI is not yet accessible on your system. <pre><code>ls: /cvmfs/software.eessi.io: No such file or directory\n</code></pre> No worries, you don't need to be a  to get access to EESSI.</p> <p>Continue reading about the Native installation of EESSI, or access via the EESSI container.</p>"},{"location":"getting_access/native_installation/","title":"Native installation","text":"<p>Setting up native access to EESSI, that is a system-wide deployment that does not require workarounds like using a container, requires the installation and configuration of CernVM-FS.</p> <p>This requires admin privileges, since you need to install CernVM-FS as an OS package.</p> <p>The following actions must be taken for a (basic) native installation of EESSI:</p> <ul> <li>Installing CernVM-FS itself, ideally using the OS packages provided by the CernVM-FS project   (although installing from source is also possible);</li> <li>Installing the EESSI configuration for CernVM-FS, which can be done by installing the <code>cvmfs-config-eessi</code>   package that we provide for the most popular Linux distributions   (more information available here);</li> <li>Creating a small client configuration file for CernVM-FS (<code>/etc/cvmfs/default.local</code>);   see also the CernVM-FS documentation.</li> </ul> <p>The good news is that all of this only requires a handful commands  :</p> RHEL-based Linux distributionsDebian-based Linux distributions <pre><code># Installation commands for RHEL-based distros like CentOS, Rocky Linux, Almalinux, Fedora, ...\n\n# install CernVM-FS\nsudo yum install -y https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest.noarch.rpm\nsudo yum install -y cvmfs\n\n# install EESSI configuration for CernVM-FS\nsudo yum install -y https://github.com/EESSI/filesystem-layer/releases/download/latest/cvmfs-config-eessi-latest.noarch.rpm\n\n# create client configuration file for CernVM-FS (no squid proxy, 10GB local CernVM-FS client cache)\nsudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"' &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000' &gt;&gt; /etc/cvmfs/default.local\"\n\n# make sure that EESSI CernVM-FS repository is accessible\nsudo cvmfs_config setup\n</code></pre> <pre><code># Installation commands for Debian-based distros like Ubuntu, ...\n\n# install CernVM-FS\nsudo apt-get install lsb-release\nwget https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nrm -f cvmfs-release-latest_all.deb\nsudo apt-get update\nsudo apt-get install -y cvmfs\n\n# install EESSI configuration for CernVM-FS\nwget https://github.com/EESSI/filesystem-layer/releases/download/latest/cvmfs-config-eessi_latest_all.deb\nsudo dpkg -i cvmfs-config-eessi_latest_all.deb\n\n# create client configuration file for CernVM-FS (no squid proxy, 10GB local CernVM-FS client cache)\nsudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"' &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000' &gt;&gt; /etc/cvmfs/default.local\"\n\n# make sure that EESSI CernVM-FS repository is accessible\nsudo cvmfs_config setup\n</code></pre> <p>Note</p> <p> The commands above only cover the basic installation of EESSI.</p> <p>This is good enough for an individual client, or for testing purposes, but for a production-quality setup you should also set up a Squid proxy cache.</p> <p>For large-scale systems, like an HPC cluster, you should also consider setting up your own CernVM-FS Stratum-1 mirror server.</p> <p>For more details on this, please refer to the Stratum 1 and proxies section of the CernVM-FS tutorial.</p>"},{"location":"meetings/2022-09-amsterdam/","title":"EESSI Community Meeting (Sept'22, Amsterdam)","text":""},{"location":"meetings/2022-09-amsterdam/#practical-info","title":"Practical info","text":"<ul> <li>dates: Wed-Fri 14-16 Sept'22</li> <li>in conjunction with CernVM workshop @ Nikhef (Mon-Tue 12-13 Sept'22)</li> <li>venue: \"Polderzaal\" at Cafe-Restaurant Polder (Google   Maps), sponsored by SURF</li> <li>registration (closed since Fri 9 Sept'22)</li> <li>Slack channel: <code>community-meeting-2022</code> in EESSI Slack</li> <li>YouTube playlist with recorded talks</li> </ul>"},{"location":"meetings/2022-09-amsterdam/#agenda","title":"Agenda","text":"<p>(subject to changes)</p> <p>We envision a mix of presentations, experience reports, demos, and hands-on sessions and/or hackathons related to the EESSI project.</p> <p>If you would like to give a talk or host a session, please let us know via the EESSI Slack!</p>"},{"location":"meetings/2022-09-amsterdam/#wed-14-sept-2022","title":"Wed 14 Sept 2022","text":"<ul> <li>[10:00-13:00] Welcome session<ul> <li>[10:00-10:30] Walk-in, coffee</li> <li>[10:30-12:00] Round table discussion (not live-streamed!)</li> </ul> </li> <li>[12:00-13:00] Lunch</li> <li>[13:00-15:00] Presentations on EESSI<ul> <li>[13:00-13:30] Introduction to EESSI (Caspar) [slides - recording]</li> <li>[13:30-14:00] Hands-on: how to use EESSI (Kenneth) [slides - recording]</li> <li>[14:00-14:30] EESSI use cases (Kenneth) [(slides - recording]</li> <li>[14:30-15:00] EESSI for sysadmins (Thomas) [slides - recording]</li> </ul> </li> <li>[15:00-15:30] Coffee break</li> <li>[15:30-17:00] Presentations on EESSI (continued)<ul> <li>[15:30-16:00] Hands-on: installing EESSI (Thomas/Kenneth)</li> <li>[16:00-16:45] ComputeCanada site talk (Bart Oldeman, remote) [slides - recording]</li> <li>[16:45-17:15] Magic Castle (Felix-Antoine Fortin, remote) [slides - recording]</li> </ul> </li> <li>[19:00-...] Group dinner @ Saravanaa Bhavan (sponsored by Dell Technologies)<ul> <li>address: Stadhouderskade 123-124, Amsterdam</li> </ul> </li> </ul>"},{"location":"meetings/2022-09-amsterdam/#thu-15-sept-2022","title":"Thu 15 Sept 2022","text":"<ul> <li>[09:30-12:00] More focused presentations on aspects of EESSI<ul> <li>[09:30-10:00] EESSI behind the scenes: compat layer (Bob) [slides - recording]</li> <li>[10:00-10:30] EESSI behind the scenes: software layer (Kenneth) [slides - recording]</li> <li>[10:30-11:00] Coffee break</li> <li>[11:00-11:30] EESSI behind the scenes: infrastructure (Terje) [slides - recording]</li> <li>[11:30-12:00] Status on RISC-V support (Kenneth) [slides - recording]</li> </ul> </li> <li>[12:00-13:00] Lunch</li> <li>[13:00-14:00] Discussions/hands-on sessions/hackathon</li> <li>[14:00-14:30] Status on GPU support (Alan) [slides - recording]</li> <li>[14:30-15:00] Status on build-and-deploy bot (Thomas) [slides - recording]</li> <li>[15:00-15:30] Coffee break</li> <li>[15:30-17:00] Discussions/hands-on sessions/hackathon (continued)<ul> <li>Hands-on with GPUs (Alan)</li> <li>Hands-on with bot (Thomas/Kenneth)</li> </ul> </li> <li>[19:00-...] Group dinner @ Italia Oggi (sponsored by HPC-UGent)<ul> <li>address: Binnen Bantammerstraat 11, Amsterdam</li> </ul> </li> </ul>"},{"location":"meetings/2022-09-amsterdam/#fri-16-sept-2022","title":"Fri 16 Sept 2022","text":"<ul> <li>[09:30-12:00] Presentations on future work<ul> <li>[09:30-10:00] Testing in software layer (Caspar) [slides - recording]</li> <li>[10:00-10:30] MultiXscale project (Alan) [slides - recording]</li> <li>[10:30-11:00] Coffee break</li> <li>[11:00-11:30] Short-term future work (Kenneth) [slides - recording]</li> </ul> </li> <li>[11:30-12:00] Discussion: future management structure of EESSI (Alan) [slides - recording]</li> <li>[12:00-13:00] Lunch</li> <li>[13:00-14:00] Site reports [recording]<ul> <li>NESSI (Thomas) [slides]</li> <li>NLPL (Stephan) [slides]</li> <li>HPCNow! (Danilo) [slides]</li> <li>Azure (Hugo) [slides]</li> </ul> </li> <li>[14:00-14:30] Discussion: what would make or break EESSI for your site? (notes - recording)</li> <li>[14:30-15:45] Discussions/hands-on sessions/hackathon<ul> <li>Hands-on with GPU support (Alan)</li> <li>Hands-on with bot (Thomas/Kenneth)</li> <li>Hands-on with software testing (Caspar)</li> </ul> </li> <li>We need to leave the room by 16:00!</li> </ul>"},{"location":"repositories/pilot/","title":"Pilot repository","text":""},{"location":"repositories/pilot/#pilot-software-stack-202112","title":"Pilot software stack (2021.12)","text":""},{"location":"repositories/pilot/#caveats","title":"Caveats","text":"<p>Danger</p> <p>The EESSI pilot repository is no longer actively maintained, and should not be used for production work.</p> <p>Please use the <code>software.eessi.io</code> repository instead.</p> <p>The current EESSI pilot software stack (version 2021.12) is the 7th iteration, and there are some known issues and limitations, please take these into account:</p> <ul> <li>First of all: the EESSI pilot software stack is NOT READY FOR PRODUCTION!</li> </ul> <p>Do not use it for production work, and be careful when testing it on production systems!</p>"},{"location":"repositories/pilot/#reporting-problems","title":"Reporting problems","text":"<p>If you notice any problems, please report them via https://github.com/EESSI/software-layer/issues.</p>"},{"location":"repositories/pilot/#accessing-the-eessi-pilot-repository-through-singularity","title":"Accessing the EESSI pilot repository through Singularity","text":"<p>The easiest way to access the EESSI pilot repository is by using Singularity. If Singularity is installed already, no admin privileges are required. No other software is needed either on the host.</p> <p>A container image is available in the GitHub Container Registry  (see https://github.com/EESSI/filesystem-layer/pkgs/container/client-pilot). It only contains a minimal operating system + the necessary packages to access the EESSI pilot repository through CernVM-FS, and it is suitable for <code>aarch64</code>, <code>ppc64le</code>, and <code>x86_64</code>.</p> <p>The container image can be used directly by Singularity (no prior download required), as follows:</p> <ul> <li> <p>First, create some local directories in <code>/tmp/$USER</code> which will be bind mounted in the container:   <pre><code>mkdir -p /tmp/$USER/{var-lib-cvmfs,var-run-cvmfs,home}\n</code></pre>   These provides space for the CernVM-FS cache, and an empty home directory to use in the container.</p> </li> <li> <p>Set the <code>$SINGULARITY_BIND</code> and <code>$SINGULARITY_HOME</code> environment variables to configure Singularity:   <pre><code>export SINGULARITY_BIND=\"/tmp/$USER/var-run-cvmfs:/var/run/cvmfs,/tmp/$USER/var-lib-cvmfs:/var/lib/cvmfs\"\nexport SINGULARITY_HOME=\"/tmp/$USER/home:/home/$USER\"\n</code></pre></p> </li> <li> <p>Start the container using <code>singularity shell</code>, using <code>--fusemount</code> to mount the EESSI pilot repository   (using the <code>cvmfs2</code> command that is included in the container image):   <pre><code>export EESSI_PILOT=\"container:cvmfs2 pilot.eessi-hpc.org /cvmfs/pilot.eessi-hpc.org\"\nsingularity shell --fusemount \"$EESSI_PILOT\" docker://ghcr.io/eessi/client-pilot:centos7\n</code></pre></p> </li> <li> <p>This should give you a shell in the container, where the EESSI pilot repository is mounted:    <pre><code>$ singularity shell --fusemount \"$EESSI_PILOT\" docker://ghcr.io/eessi/client-pilot:centos7\nINFO:    Using cached SIF image\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nSingularity&gt;\n</code></pre></p> </li> <li>It is possible that you see some scary looking warnings, but those can be ignored for now.</li> </ul> <p>To verify that things are working, check the contents of the <code>/cvmfs/pilot.eessi-hpc.org/versions/2021.12</code> directory:    <pre><code>Singularity&gt; ls /cvmfs/pilot.eessi-hpc.org/versions/2021.12\ncompat  init  software\n</code></pre></p>"},{"location":"repositories/pilot/#standard-installation","title":"Standard installation","text":"<p>For those with privileges on their system, there are a number of example installation scripts for different architectures and operating systems available in the EESSI demo repository.</p> <p>Here we prefer the Singularity approach as we can guarantee that the container image is up to date.</p>"},{"location":"repositories/pilot/#setting-up-the-eessi-environment","title":"Setting up the EESSI environment","text":"<p>Once you have the EESSI pilot repository mounted, you can set up the environment by sourcing the provided init script:</p> <pre><code>source /cvmfs/pilot.eessi-hpc.org/versions/2021.12/init/bash\n</code></pre> <p>If all goes well, you should see output like this:</p> <pre><code>Found EESSI pilot repo @ /cvmfs/pilot.eessi-hpc.org/versions/2021.12!\nUsing x86_64/intel/haswell as software subdirectory.\nUsing /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all as the directory to be added to MODULEPATH.\nFound Lmod configuration file at /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/.lmod/lmodrc.lua\nInitializing Lmod...\nPrepending /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI pilot software stack, have fun!\n[EESSI pilot 2021.12] $ \n</code></pre> <p>Now you're all set up! Go ahead and explore the software stack using \"<code>module avail</code>\", and go wild with testing the available software installations!</p>"},{"location":"repositories/pilot/#testing-the-eessi-pilot-software-stack","title":"Testing the EESSI pilot software stack","text":"<p>Please test the EESSI pilot software stack as you see fit: running simple commands, performing small calculations or running small benchmarks, etc.</p> <p>Test scripts that have been verified to work correctly using the pilot software stack are available at https://github.com/EESSI/software-layer/tree/main/tests .</p>"},{"location":"repositories/pilot/#giving-feedback-or-reporting-problems","title":"Giving feedback or reporting problems","text":"<p>Any feedback is welcome, and questions or problems reports are welcome as well, through one of the EESSI communication channels:</p> <ul> <li>(preferred!) EESSI <code>software-layer</code> GitHub repository: https://github.com/EESSI/software-layer/issues</li> <li>EESSI mailing list (<code>eessi@list.rug.nl</code>)</li> <li>EESSI Slack: https://eessi-hpc.slack.com (get an invite via https://www.eessi-hpc.org/join)</li> <li>monthly EESSI meetings (first Thursday of the month at 2pm CEST)</li> </ul>"},{"location":"repositories/pilot/#available-software","title":"Available software","text":"<p>(last update: Mar 21st 2022)</p> <p>EESSI currently supports the following HPC applications as well as all their dependencies:</p> <ul> <li>GROMACS (2020.1 and 2020.4)</li> <li>OpenFOAM (v2006 and 8)</li> <li>R (4.0.0) + R-bundle-Bioconductor (3.11) + RStudio Server (1.3.1093)</li> <li>TensorFlow (2.3.1) and Horovod (0.21.3)</li> <li>OSU-Micro-Benchmarks (5.6.3)</li> <li>ReFrame (3.9.1)</li> <li>Spark (3.1.1)</li> <li>IPython (7.15.0)</li> <li>QuantumESPRESSO (6.6) (currently not available on <code>ppc64le</code>)</li> <li>WRF (3.9.1.1)</li> </ul> <pre><code>[EESSI pilot 2021.12] $ module --nx avail\n\n--------------------------- /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all ----------------------------\n   ant/1.10.8-Java-11                                              LMDB/0.9.24-GCCcore-9.3.0\n   Arrow/0.17.1-foss-2020a-Python-3.8.2                            lz4/1.9.2-GCCcore-9.3.0\n   Bazel/3.6.0-GCCcore-9.3.0                                       Mako/1.1.2-GCCcore-9.3.0\n   Bison/3.5.3-GCCcore-9.3.0                                       MariaDB-connector-c/3.1.7-GCCcore-9.3.0\n   Boost/1.72.0-gompi-2020a                                        matplotlib/3.2.1-foss-2020a-Python-3.8.2\n   cairo/1.16.0-GCCcore-9.3.0                                      Mesa/20.0.2-GCCcore-9.3.0\n   CGAL/4.14.3-gompi-2020a-Python-3.8.2                            Meson/0.55.1-GCCcore-9.3.0-Python-3.8.2\n   CMake/3.16.4-GCCcore-9.3.0                                      METIS/5.1.0-GCCcore-9.3.0\n   CMake/3.20.1-GCCcore-10.3.0                                     MPFR/4.0.2-GCCcore-9.3.0\n   code-server/3.7.3                                               NASM/2.14.02-GCCcore-9.3.0\n   DB/18.1.32-GCCcore-9.3.0                                        ncdf4/1.17-foss-2020a-R-4.0.0\n   DB/18.1.40-GCCcore-10.3.0                                       netCDF-Fortran/4.5.2-gompi-2020a\n   double-conversion/3.1.5-GCCcore-9.3.0                           netCDF/4.7.4-gompi-2020a\n   Doxygen/1.8.17-GCCcore-9.3.0                                    nettle/3.6-GCCcore-9.3.0\n   EasyBuild/4.5.0                                                 networkx/2.4-foss-2020a-Python-3.8.2\n   EasyBuild/4.5.1                                         (D)     Ninja/1.10.0-GCCcore-9.3.0\n   Eigen/3.3.7-GCCcore-9.3.0                                       NLopt/2.6.1-GCCcore-9.3.0\n   Eigen/3.3.9-GCCcore-10.3.0                                      NSPR/4.25-GCCcore-9.3.0\n   ELPA/2019.11.001-foss-2020a                                     NSS/3.51-GCCcore-9.3.0\n   expat/2.2.9-GCCcore-9.3.0                                       nsync/1.24.0-GCCcore-9.3.0\n   expat/2.2.9-GCCcore-10.3.0                                      numactl/2.0.13-GCCcore-9.3.0\n   FFmpeg/4.2.2-GCCcore-9.3.0                                      numactl/2.0.14-GCCcore-10.3.0\n   FFTW/3.3.8-gompi-2020a                                          OpenBLAS/0.3.9-GCC-9.3.0\n   FFTW/3.3.9-gompi-2021a                                          OpenBLAS/0.3.15-GCC-10.3.0\n   flatbuffers/1.12.0-GCCcore-9.3.0                                OpenFOAM/v2006-foss-2020a\n   FlexiBLAS/3.0.4-GCC-10.3.0                                      OpenFOAM/8-foss-2020a                              (D)\n   fontconfig/2.13.92-GCCcore-9.3.0                                OpenMPI/4.0.3-GCC-9.3.0\n   foss/2020a                                                      OpenMPI/4.1.1-GCC-10.3.0\n   foss/2021a                                                      OpenPGM/5.2.122-GCCcore-9.3.0\n   freetype/2.10.1-GCCcore-9.3.0                                   OpenSSL/1.1                                        (D)\n   FriBidi/1.0.9-GCCcore-9.3.0                                     OSU-Micro-Benchmarks/5.6.3-gompi-2020a\n   GCC/9.3.0                                                       Pango/1.44.7-GCCcore-9.3.0\n   GCC/10.3.0                                                      ParaView/5.8.0-foss-2020a-Python-3.8.2-mpi\n   GCCcore/9.3.0                                                   PCRE/8.44-GCCcore-9.3.0\n   GCCcore/10.3.0                                                  PCRE2/10.34-GCCcore-9.3.0\n   Ghostscript/9.52-GCCcore-9.3.0                                  Perl/5.30.2-GCCcore-9.3.0\n   giflib/5.2.1-GCCcore-9.3.0                                      Perl/5.32.1-GCCcore-10.3.0\n   git/2.23.0-GCCcore-9.3.0-nodocs                                 pixman/0.38.4-GCCcore-9.3.0\n   git/2.32.0-GCCcore-10.3.0-nodocs                        (D)     pkg-config/0.29.2-GCCcore-9.3.0\n   GLib/2.64.1-GCCcore-9.3.0                                       pkg-config/0.29.2-GCCcore-10.3.0\n   GLPK/4.65-GCCcore-9.3.0                                         pkg-config/0.29.2                                  (D)\n   GMP/6.2.0-GCCcore-9.3.0                                         pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2\n   GMP/6.2.1-GCCcore-10.3.0                                        PMIx/3.1.5-GCCcore-9.3.0\n   gnuplot/5.2.8-GCCcore-9.3.0                                     PMIx/3.2.3-GCCcore-10.3.0\n   GObject-Introspection/1.64.0-GCCcore-9.3.0-Python-3.8.2         poetry/1.0.9-GCCcore-9.3.0-Python-3.8.2\n   gompi/2020a                                                     protobuf-python/3.13.0-foss-2020a-Python-3.8.2\n   gompi/2021a                                                     protobuf/3.13.0-GCCcore-9.3.0\n   groff/1.22.4-GCCcore-9.3.0                                      pybind11/2.4.3-GCCcore-9.3.0-Python-3.8.2\n   groff/1.22.4-GCCcore-10.3.0                                     pybind11/2.6.2-GCCcore-10.3.0\n   GROMACS/2020.1-foss-2020a-Python-3.8.2                          Python/2.7.18-GCCcore-9.3.0\n   GROMACS/2020.4-foss-2020a-Python-3.8.2                  (D)     Python/3.8.2-GCCcore-9.3.0\n   GSL/2.6-GCC-9.3.0                                               Python/3.9.5-GCCcore-10.3.0-bare\n   gzip/1.10-GCCcore-9.3.0                                         Python/3.9.5-GCCcore-10.3.0\n   h5py/2.10.0-foss-2020a-Python-3.8.2                             PyYAML/5.3-GCCcore-9.3.0\n   HarfBuzz/2.6.4-GCCcore-9.3.0                                    Qt5/5.14.1-GCCcore-9.3.0\n   HDF5/1.10.6-gompi-2020a                                         QuantumESPRESSO/6.6-foss-2020a\n   Horovod/0.21.3-foss-2020a-TensorFlow-2.3.1-Python-3.8.2         R-bundle-Bioconductor/3.11-foss-2020a-R-4.0.0\n   hwloc/2.2.0-GCCcore-9.3.0                                       R/4.0.0-foss-2020a\n   hwloc/2.4.1-GCCcore-10.3.0                                      re2c/1.3-GCCcore-9.3.0\n   hypothesis/6.13.1-GCCcore-10.3.0                                RStudio-Server/1.3.1093-foss-2020a-Java-11-R-4.0.0\n   ICU/66.1-GCCcore-9.3.0                                          Rust/1.52.1-GCCcore-10.3.0\n   ImageMagick/7.0.10-1-GCCcore-9.3.0                              ScaLAPACK/2.1.0-gompi-2020a\n   IPython/7.15.0-foss-2020a-Python-3.8.2                          ScaLAPACK/2.1.0-gompi-2021a-fb\n   JasPer/2.0.14-GCCcore-9.3.0                                     scikit-build/0.10.0-foss-2020a-Python-3.8.2\n   Java/11.0.2                                             (11)    SciPy-bundle/2020.03-foss-2020a-Python-3.8.2\n   jbigkit/2.1-GCCcore-9.3.0                                       SciPy-bundle/2021.05-foss-2021a\n   JsonCpp/1.9.4-GCCcore-9.3.0                                     SCOTCH/6.0.9-gompi-2020a\n   LAME/3.100-GCCcore-9.3.0                                        snappy/1.1.8-GCCcore-9.3.0\n   libarchive/3.5.1-GCCcore-10.3.0                                 Spark/3.1.1-foss-2020a-Python-3.8.2\n   libcerf/1.13-GCCcore-9.3.0                                      SQLite/3.31.1-GCCcore-9.3.0\n   libdrm/2.4.100-GCCcore-9.3.0                                    SQLite/3.35.4-GCCcore-10.3.0\n   libevent/2.1.11-GCCcore-9.3.0                                   SWIG/4.0.1-GCCcore-9.3.0\n   libevent/2.1.12-GCCcore-10.3.0                                  Szip/2.1.1-GCCcore-9.3.0\n   libfabric/1.11.0-GCCcore-9.3.0                                  Tcl/8.6.10-GCCcore-9.3.0\n   libfabric/1.12.1-GCCcore-10.3.0                                 Tcl/8.6.11-GCCcore-10.3.0\n   libffi/3.3-GCCcore-9.3.0                                        tcsh/6.22.02-GCCcore-9.3.0\n   libffi/3.3-GCCcore-10.3.0                                       TensorFlow/2.3.1-foss-2020a-Python-3.8.2\n   libgd/2.3.0-GCCcore-9.3.0                                       time/1.9-GCCcore-9.3.0\n   libGLU/9.0.1-GCCcore-9.3.0                                      Tk/8.6.10-GCCcore-9.3.0\n   libglvnd/1.2.0-GCCcore-9.3.0                                    Tkinter/3.8.2-GCCcore-9.3.0\n   libiconv/1.16-GCCcore-9.3.0                                     UCX/1.8.0-GCCcore-9.3.0\n   libjpeg-turbo/2.0.4-GCCcore-9.3.0                               UCX/1.10.0-GCCcore-10.3.0\n   libpciaccess/0.16-GCCcore-9.3.0                                 UDUNITS/2.2.26-foss-2020a\n   libpciaccess/0.16-GCCcore-10.3.0                                UnZip/6.0-GCCcore-9.3.0\n   libpng/1.6.37-GCCcore-9.3.0                                     UnZip/6.0-GCCcore-10.3.0\n   libsndfile/1.0.28-GCCcore-9.3.0                                 WRF/3.9.1.1-foss-2020a-dmpar\n   libsodium/1.0.18-GCCcore-9.3.0                                  X11/20200222-GCCcore-9.3.0\n   LibTIFF/4.1.0-GCCcore-9.3.0                                     x264/20191217-GCCcore-9.3.0\n   libtirpc/1.2.6-GCCcore-9.3.0                                    x265/3.3-GCCcore-9.3.0\n   libunwind/1.3.1-GCCcore-9.3.0                                   xorg-macros/1.19.2-GCCcore-9.3.0\n   libxc/4.3.4-GCC-9.3.0                                           xorg-macros/1.19.3-GCCcore-10.3.0\n   libxml2/2.9.10-GCCcore-9.3.0                                    Xvfb/1.20.9-GCCcore-9.3.0\n   libxml2/2.9.10-GCCcore-10.3.0                                   Yasm/1.3.0-GCCcore-9.3.0\n   libyaml/0.2.2-GCCcore-9.3.0                                     ZeroMQ/4.3.2-GCCcore-9.3.0\n   LittleCMS/2.9-GCCcore-9.3.0                                     Zip/3.0-GCCcore-9.3.0\n   LLVM/9.0.1-GCCcore-9.3.0                                        zstd/1.4.4-GCCcore-9.3.0\n</code></pre>"},{"location":"repositories/pilot/#architecture-and-micro-architecture-support","title":"Architecture and micro-architecture support","text":""},{"location":"repositories/pilot/#x86_64","title":"x86_64","text":"<ul> <li>generic (currently implies <code>march=x86-64</code> and <code>-mtune=generic</code>)</li> <li>AMD<ul> <li>zen2 (Rome)</li> <li>zen3 (Milan)</li> </ul> </li> <li>Intel<ul> <li>haswell</li> <li>skylake_avx512</li> </ul> </li> </ul>"},{"location":"repositories/pilot/#aarch64arm64","title":"aarch64/arm64","text":"<ul> <li>generic (currently implies <code>-march=armv8-a</code> and <code>-mtune=generic</code>)</li> <li>AWS Graviton2</li> </ul>"},{"location":"repositories/pilot/#ppc64le","title":"ppc64le","text":"<ul> <li>generic</li> <li>power9le</li> </ul>"},{"location":"repositories/pilot/#easybuild-configuration","title":"EasyBuild configuration","text":"<p>EasyBuild v4.5.1 was used to install the software in the <code>2021.12</code> version of the pilot repository. For some installations pull requests with changes that will be included in later EasyBuild versions were leveraged, see the build script that was used.</p> <p>An example configuration of the build environment based on https://github.com/EESSI/software-layer can be seen here: <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath         (E) = /tmp/eessi-build/easybuild/build\ncontainerpath     (E) = /tmp/eessi-build/easybuild/containers\ndebug             (E) = True\nfilter-deps       (E) = Autoconf, Automake, Autotools, binutils, bzip2, cURL, DBus, flex, gettext, gperf, help2man, intltool, libreadline, libtool, Lua, M4, makeinfo, ncurses, util-linux, XZ, zlib\nfilter-env-vars   (E) = LD_LIBRARY_PATH\nhooks             (E) = /home/eessi-build/software-layer/eb_hooks.py\nignore-osdeps     (E) = True\ninstallpath       (E) = /cvmfs/pilot.eessi-hpc.org/2021.06/software/linux/x86_64/intel/haswell\nmodule-extensions (E) = True\npackagepath       (E) = /tmp/eessi-build/easybuild/packages\nprefix            (E) = /tmp/eessi-build/easybuild\nrepositorypath    (E) = /tmp/eessi-build/easybuild/ebfiles_repo\nrobot-paths       (D) = /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/software/EasyBuild/4.5.1/easybuild/easyconfigs\nrpath             (E) = True\nsourcepath        (E) = /tmp/eessi-build/easybuild/sources:\nsysroot           (E) = /cvmfs/pilot.eessi-hpc.org/versions/2021.12/compat/linux/x86_64\ntrace             (E) = True\nzip-logs          (E) = bzip2\n</code></pre></p>"},{"location":"repositories/pilot/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for the pilot repository is shown http://status.eessi-infra.org.</p>"},{"location":"repositories/riscv.eessi.io/","title":"EESSI RISC-V development repository (<code>riscv.eessi.io</code>)","text":"<p>This repository contains development versions of an EESSI RISC-V software stack. Note that versions may be added, modified, or deleted at any time.</p>"},{"location":"repositories/riscv.eessi.io/#accessing-the-risc-v-repository","title":"Accessing the RISC-V repository","text":"<p>See Getting access; by making the EESSI CVMFS domain available, you will automatically have access to <code>riscv.eessi.io</code> as well.</p>"},{"location":"repositories/riscv.eessi.io/#using-riscveessiio","title":"Using <code>riscv.eessi.io</code>","text":"<p>This repository is not ready to be used yet, as no initialization scripts nor actual applications are available yet. Also, it is not clear yet which RISC-V CPUs will be supported.</p>"},{"location":"repositories/riscv.eessi.io/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for this repository is shown at https://status.eessi.io.</p>"},{"location":"repositories/software.eessi.io/","title":"Production EESSI repository (<code>software.eessi.io</code>)","text":""},{"location":"repositories/software.eessi.io/#question-or-problems","title":"Question or problems","text":"<p>If you have any questions regarding EESSI, or if you experience a problem in accessing or using it, please open a support request.</p>"},{"location":"repositories/software.eessi.io/#accessing-the-eessi-repository","title":"Accessing the EESSI repository","text":"<p>See Getting access.</p>"},{"location":"repositories/software.eessi.io/#using-softwareeessiio","title":"Using <code>software.eessi.io</code>","text":"<p>See Using EESSI.</p>"},{"location":"repositories/software.eessi.io/#available-software","title":"Available software","text":"<p>Detailed overview of available software coming soon!</p> <p>For now, use <code>module avail</code> after initializing the EESSI environment.</p>"},{"location":"repositories/software.eessi.io/#architecture-and-micro-architecture-support","title":"Architecture and micro-architecture support","text":"<p>See CPU targets.</p>"},{"location":"repositories/software.eessi.io/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for the production repository is shown at https://status.eessi.io.</p>"},{"location":"software_layer/build_nodes/","title":"Build nodes","text":"<p>Any system can be used as a build node to create additional software installations that should be added to the EESSI CernVM-FS repository.</p>"},{"location":"software_layer/build_nodes/#requirements","title":"Requirements","text":"<p>OS and software:</p> <ul> <li>GNU/Linux (any distribution) as operating system;</li> <li>a recent version of Singularity (&gt;= 3.6 is recommended);<ul> <li>check with <code>singularity --version</code></li> </ul> </li> <li><code>screen</code> or <code>tmux</code> is highly recommended;</li> </ul> <p>Admin privileges are not required, as long as Singularity is installed.</p> <p>Resources:</p> <ul> <li>8 or more cores is recommended (though not strictly required);</li> <li>at least 50GB of free space on a local filesystem (like <code>/tmp</code>);</li> <li>at least 16GB of memory (2GB/core or higher recommended);</li> </ul> <p>Instructions to install Singularity and screen (click to show commands):</p> CentOS 8 (<code>x86_64</code> or <code>aarch64</code> or <code>ppc64le</code>) <pre><code>sudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\nsudo dnf update -y\nsudo dnf install -y screen singularity\n</code></pre>"},{"location":"software_layer/build_nodes/#setting-up-the-container","title":"Setting up the container","text":"<p>Warning</p> <p>It is highly recommended to start a <code>screen</code> or <code>tmux</code> session first!</p> <p>A container image is provided that includes everything that is required to set up a writable overlay on top of the EESSI CernVM-FS repository.</p> <p>First, pick a location on a local filesystem for the temporary directory:</p> <p>Requirements:</p> <ul> <li>Do not use a shared filesystem like NFS, Lustre or GPFS.</li> <li>There should be at least 50GB of free disk space in this local filesystem (more is better).</li> <li>There should be no automatic cleanup of old files via a cron job on this local filesystem.</li> <li>Try to make sure the directory is unique (not used by anything else).</li> </ul> <p>NB. If you are going to install on a separate drive (due to lack of space on /), then you need to set some variables to  point to that location. You will also need to bind mount it in the <code>singularity</code> command. Let's say that you drive is  mounted in /srt. Then you change the relevant commands below to this: <pre><code>export EESSI_TMPDIR=/srt/$USER/EESSI\nmkdir -p $EESSI_TMPDIR\nmkdir /srt/tmp\nexport SINGULARITY_BIND=\"$EESSI_TMPDIR/var-run-cvmfs:/var/run/cvmfs,$EESSI_TMPDIR/var-lib-cvmfs:/var/lib/cvmfs,/srt/tmp:/tmp\"\nsingularity shell -B /srt --fusemount \"$EESSI_READONLY\" --fusemount \"$EESSI_WRITABLE_OVERLAY\" docker://ghcr.io/eessi/build-node:debian10\n</code></pre></p> <p>We will assume that <code>/tmp/$USER/EESSI</code> meets these requirements:</p> <pre><code>export EESSI_TMPDIR=/tmp/$USER/EESSI\nmkdir -p $EESSI_TMPDIR\n</code></pre> <p>Create some subdirectories in this temporary directory:</p> <pre><code>mkdir -p $EESSI_TMPDIR/{home,overlay-upper,overlay-work}\nmkdir -p $EESSI_TMPDIR/{var-lib-cvmfs,var-run-cvmfs}\n</code></pre> <p>Configure Singularity cache directory, bind mounts, and (fake) home directory:</p> <pre><code>export SINGULARITY_CACHEDIR=$EESSI_TMPDIR/singularity_cache\nexport SINGULARITY_BIND=\"$EESSI_TMPDIR/var-run-cvmfs:/var/run/cvmfs,$EESSI_TMPDIR/var-lib-cvmfs:/var/lib/cvmfs\"\nexport SINGULARITY_HOME=\"$EESSI_TMPDIR/home:/home/$USER\"\n</code></pre> <p>Define values to pass to <code>--fusemount` in</code>singularity`` command:</p> <pre><code>export EESSI_READONLY=\"container:cvmfs2 software.eessi.io /cvmfs_ro/software.eessi.io\"\nexport EESSI_WRITABLE_OVERLAY=\"container:fuse-overlayfs -o lowerdir=/cvmfs_ro/software.eessi.io -o upperdir=$EESSI_TMPDIR/overlay-upper -o workdir=$EESSI_TMPDIR/overlay-work /cvmfs/software.eessi.io\"\n</code></pre> <p>Start the container (which includes Debian 10, CernVM-FS and fuse-overlayfs):</p> <pre><code>singularity shell --fusemount \"$EESSI_READONLY\" --fusemount \"$EESSI_WRITABLE_OVERLAY\" docker://ghcr.io/eessi/build-node:debian10\n</code></pre> <p>Once the container image has been downloaded and converted to a Singularity image (SIF format), you should get a prompt like this:</p> <pre><code>...\nCernVM-FS: loading Fuse module... done\n\nSingularity&gt;\n</code></pre> <p>and the EESSI CernVM-FS repository should be mounted:</p> <pre><code>Singularity&gt; ls /cvmfs/software.eessi.io\nhost_injections  README.eessi  versions\n</code></pre>"},{"location":"software_layer/build_nodes/#setting-up-the-environment","title":"Setting up the environment","text":"<p>Set up the environment by starting a Gentoo Prefix session using the <code>startprefix</code> command.</p> <p>Make sure you use the correct version of the EESSI repository!</p> <pre><code>export EESSI_VERSION='2023.06'\n/cvmfs/software.eessi.io/${EESSI_VERSION}/compat/linux/$(uname -m)/startprefix\n</code></pre>"},{"location":"software_layer/build_nodes/#installing-software","title":"Installing software","text":"<p>Clone the software-layer repository:</p> <pre><code>git clone https://github.com/EESSI/software-layer.git\n</code></pre> <p>Run the software installation script in <code>software-layer</code>:</p> <pre><code>cd software-layer\n./EESSI-install-software.sh\n</code></pre> <p>This script will figure out the CPU microarchitecture of the host automatically (like <code>x86_64/intel/haswell</code>).</p> <p>To build generic software installations (like <code>x86_64/generic</code>), use the <code>--generic</code> option:</p> <pre><code>./EESSI-install-software.sh --generic\n</code></pre> <p>Once all missing software has been installed, you should see a message like this:</p> <pre><code>No missing modules!\n</code></pre>"},{"location":"software_layer/build_nodes/#creating-tarball-to-ingest","title":"Creating tarball to ingest","text":"<p>Before tearing down the build node, you should create tarball to ingest into the EESSI CernVM-FS repository.</p> <p>To create a tarball of all installations, assuming your build host is <code>x86_64/intel/haswell</code>:</p> <pre><code>export EESSI_VERSION='2023.06'\ncd /cvmfs/software.eessi.io/${EESSI_VERSION}/software/linux\neessi_tar_gz=\"$HOME/eessi-${EESSI_VERSION}-haswell.tar.gz\"\ntar cvfz ${eessi_tar_gz} x86_64/intel/haswell\n</code></pre> <p>To create a tarball for specific installations, make sure you pick up both the software installation directories and the corresponding module files:</p> <pre><code>eessi_tar_gz=\"$HOME/eessi-${EESSI_VERSION}-haswell-OpenFOAM.tar.gz\"\n\ntar cvfz ${eessi_tar_gz} x86_64/intel/haswell/software/OpenFOAM modules/all//OpenFOAM\n</code></pre> <p>This tarball should be uploaded to the Stratum 0 server for ingestion. If needed, you can ask for help in the EESSI <code>#software-layer</code> Slack channel</p>"},{"location":"software_layer/cpu_targets/","title":"CPU targets","text":"<p>In the 2023.06 version of the EESSI repository, the following CPU microarchitectures are supported.</p> <ul> <li><code>aarch64/generic</code>: fallback for Arm 64-bit CPUs (like Raspberri Pi, etc.)</li> <li><code>aarch64/neoverse_n1</code>: AWS Graviton 2, Ampere Altra, ...</li> <li><code>aarch64/neoverse_v1</code>: AWS Graviton 3</li> <li><code>x86_64/generic</code>: fallback for older Intel + AMD CPUs (like Intel Sandy Bridge, ...)</li> <li><code>x86_64/amd/zen2</code>: AMD Rome</li> <li><code>x86_64/amd/zen3</code>: AMD Milan, AMD Milan X</li> <li><code>x86_64/intel/haswell</code>: Intel Haswell, Broadwell</li> <li><code>x86_64/intel/skylake_avx512</code>: Intel Skylake, Cascade Lake, Ice Lake, ...</li> </ul> <p>The names of these CPU targets correspond to the names used by archspec.</p>"},{"location":"talks/20230615_aws_tech_short/","title":"Making scientific software EESSI - and fast","text":"<p>AWS HPC Tech Short (~8 min.) - 15 June 2023</p>"},{"location":"talks/2023/20230615_aws_tech_short/","title":"Making scientific software EESSI - and fast","text":"<p>AWS HPC Tech Short (~8 min.) - 15 June 2023</p>"},{"location":"talks/2023/20231027_packagingcon23_eessi/","title":"Streaming optimized scientific software installations on any Linux distro with EESSI","text":"<ul> <li>PackagingCon'2023 (Berlin, Germany) - 27 Oct 2023</li> <li>presented by Kenneth Hoste &amp; Lara Peeters (HPC-UGent)</li> <li>slides (PDF)</li> </ul>"},{"location":"talks/2023/20231204_cvmfs_hpc/","title":"Best Practices for CernVM-FS in HPC","text":"<ul> <li>online tutorial (~3h15min), 4 Dec 2023</li> <li>presented by Kenneth Hoste (HPC-UGent)</li> <li>tutorial website: https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices</li> <li>slides (PDF)</li> </ul>"},{"location":"talks/2023/20231205_castiel2_eessi_intro/","title":"Streaming Optimised Scientific Software: an Introduction to EESSI","text":"<ul> <li>online tutorial (~1h40min) - 5 Dec 2023</li> <li>presented by Alan O'Cais (CECAM)</li> <li>slides (PDF)</li> </ul>"},{"location":"test-suite/","title":"EESSI test suite","text":"<p>The EESSI test suite is a collection of tests that are run using ReFrame. It is used to check whether the software installations included in the EESSI software layer are working and performing as expected.</p> <p>To get started, you should look into the installation and configuration guidelines first.</p> <p>To write the ReFrame configuration file for your system, check ReFrame configuration file.</p> <p>For which software tests are available, see available-tests.md.</p> <p>For more information on using the EESSI test suite, see here.</p> <p>See also release notes for the EESSI test suite.</p>"},{"location":"test-suite/ReFrame-configuration-file/","title":"ReFrame configuration file","text":"<p>In order for ReFrame to run tests on your system, it needs to know some properties about your system. For example, it needs to know what kind of job scheduler you have, which partitions the system has, how to submit to those partitions, etc. All of this has to be described in a ReFrame configuration file (see also the section on <code>$RFM_CONFIG_FILES</code> above).</p> <p>This page is organized as follows:</p> <ul> <li>available ReFrame configuration file</li> <li>Verifying your ReFrame configuration</li> <li>How to write a ReFrame configuration file</li> </ul>"},{"location":"test-suite/ReFrame-configuration-file/#available-reframe-configuration-file","title":"Available ReFrame configuration file","text":"<p>There are some available ReFrame configuration files for HPC systems and public cloud in the config directory for more inspiration. Below is a simple ReFrame configuration file with minimal changes required for getting you started on using the test suite for a CPU partition. Please check that <code>stagedir</code> is set to a path on a (shared) scratch filesystem for storing (temporary) files related to the tests, and <code>access</code> is set to a list of arguments that you would normally pass to the scheduler when submitting to this partition (for example '-p cpu' for submitting to a Slurm partition called cpu).</p> <p>To write a ReFrame configuration file for your system, check the section How to write a ReFrame configuration file.  </p> <pre><code>\"\"\"\nsimple ReFrame configuration file\n\"\"\"\nimport os\n\nfrom eessi.testsuite.common_config import common_logging_config, common_eessi_init, format_perfvars, perflog_format\nfrom eessi.testsuite.constants import *  \n\nsite_configuration = {\n    'systems': [\n        {\n            'name': 'cpu_partition',\n            'descr': 'CPU partition',\n            'modules_system': 'lmod',\n            'hostnames': ['*'],\n            # Note that the stagedir should be a shared directory available on all nodes running ReFrame tests\n            'stagedir': f'/some/shared/dir/{os.environ.get(\"USER\")}/reframe_output/staging',\n            'partitions': [\n                {\n                    'name': 'cpu_partition',\n                    'descr': 'CPU partition',\n                    'scheduler': 'slurm',\n                    'launcher': 'mpirun',\n                    'access':  ['-p cpu', '--export=None'],\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'resources': [\n                        {\n                            'name': 'memory',\n                            'options': ['--mem={size}'],\n                        }\n                    ],\n                    'features': [\n                        FEATURES[CPU]\n                    ] + list(SCALES.keys()),\n                }\n            ]\n        },\n    ],\n    'environments': [\n        {\n            'name': 'default',\n            'cc': 'cc',\n            'cxx': '',\n            'ftn': '',\n        },\n    ],\n    'logging': common_logging_config(),\n    'general': [\n        {\n            # Enable automatic detection of CPU architecture for each partition\n            # See https://reframe-hpc.readthedocs.io/en/stable/configure.html#auto-detecting-processor-information\n            'remote_detect': True,\n        }\n    ],\n}\n\n# optional logging to syslog\nsite_configuration['logging'][0]['handlers_perflog'].append({\n    'type': 'syslog',\n    'address': '/dev/log',\n    'level': 'info',\n    'format': f'reframe: {perflog_format}',\n    'format_perfvars': format_perfvars,\n    'append': True,\n})\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#verifying-your-reframe-configuration","title":"Verifying your ReFrame configuration","text":"<p>To verify the ReFrame configuration, you can query the configuration using <code>--show-config</code>.</p> <p>To see the full configuration, use:</p> <pre><code>reframe --show-config\n</code></pre> <p>To only show the configuration of a particular system partition, you can use the <code>--system</code> option. To query a specific setting, you can pass an argument to <code>--show-config</code>.</p> <p>For example, to show the configuration of the <code>gpu</code> partition of the <code>example</code> system:</p> <pre><code>reframe --system example:gpu --show-config systems/0/partitions\n</code></pre> <p>You can drill it down further to only show the value of a particular configuration setting.</p> <p>For example, to only show the <code>launcher</code> value for the <code>gpu</code> partition of the <code>example</code> system:</p> <pre><code>reframe --system example:gpu --show-config systems/0/partitions/@gpu/launcher\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#how-to-write-a-reframe-configuration-file","title":"How to write a ReFrame configuration file","text":"<p>The official ReFrame documentation provides the full description on configuring ReFrame for your site. However, there are some configuration settings that are specifically required for the EESSI test suite. Also, there are a large amount of configuration settings available in ReFrame, which makes the official documentation potentially a bit overwhelming.</p> <p>Here, we will describe how to create a configuration file that works with the EESSI test suite, starting from an example configuration file <code>settings_example.py</code>, which defines the most common configuration settings.</p>"},{"location":"test-suite/ReFrame-configuration-file/#python-imports","title":"Python imports","text":"<p>The EESSI test suite standardizes a few string-based values as constants, as well as the logging format used by ReFrame. Every ReFrame configuration file used for running the EESSI test suite should therefore start with the following import statements:</p> <pre><code>from eessi.testsuite.common_config import common_logging_config, common_eessi_init\nfrom eessi.testsuite.constants import *\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#high-level-system-info-systems","title":"High-level system info (<code>systems</code>)","text":"<p>First, we describe the system at its highest level through the <code>systems</code> keyword.</p> <p>You can define multiple systems in a single configuration file (<code>systems</code> is a Python list value). We recommend defining just a single system in each configuration file, as it makes the configuration file a bit easier to digest (for humans).</p> <p>An example of the <code>systems</code> section of the configuration file would be:</p> <pre><code>site_configuration = {\n    'systems': [\n    # We could list multiple systems. Here, we just define one\n        {\n            'name': 'example',\n            'descr': 'Example cluster',\n            'modules_system': 'lmod',\n            'hostnames': ['*'],\n            'stagedir': f'/some/shared/dir/{os.environ.get(\"USER\")}/reframe_output/staging',\n            'partitions': [...],\n        }\n    ]\n}\n</code></pre> <p>The most common configuration items defined at this level are:</p> <ul> <li><code>name</code>:   The name of the system. Pick whatever makes sense for you.</li> <li><code>descr</code>:   Description of the system. Again, pick whatever you like.</li> <li><code>modules_system</code>:   The modules system used on your system. EESSI provides modules in <code>lmod</code> format. There is no need to change this,   unless you want to run tests from the EESSI test suite with non-EESSI modules.</li> <li><code>hostnames</code>:   The names of the hosts on which you will run the ReFrame command, as regular expression. Using these names,   ReFrame can automatically determine which of the listed configurations in the <code>systems</code> list to use, which is useful   if you're defining multiple systems in a single configuration file. If you follow our recommendation to limit   yourself to one system per configuration file, simply define <code>'hostnames': ['*']</code>.</li> <li><code>prefix</code>:   Prefix directory for a ReFrame run on this system. Any directories or files produced by ReFrame will use this prefix,   if not specified otherwise.   We recommend setting the <code>$RFM_PREFIX</code> environment variable rather than specifying <code>prefix</code> in   your configuration file, so our common logging configuration can pick up on it   (see also <code>$RFM_PREFIX</code>).</li> <li><code>stagedir</code>: A shared directory that is available on all nodes that will execute ReFrame tests. This is used for storing (temporary) files related to the test. Typically, you want to set this to a path on a (shared) scratch filesystem. Defining this is optional: the default is a '<code>stage</code>' directory inside the <code>prefix</code> directory.</li> <li><code>partitions</code>: Details on system partitions, see below.</li> </ul>"},{"location":"test-suite/ReFrame-configuration-file/#partitions","title":"System partitions (<code>systems.partitions</code>)","text":"<p>The next step is to add the system partitions to the configuration files, which is also specified as a Python list since a system can have multiple partitions.</p> <p>The <code>partitions</code> section of the configuration for a system with two Slurm partitions (one CPU partition, and one GPU partition) could for example look something like this:</p> <pre><code>site_configuration = {\n    'systems': [\n        {\n            ...\n            'partitions': [\n                {\n                    'name': 'cpu_partition',\n                    'descr': 'CPU partition'\n                    'scheduler': 'slurm',\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'launcher': 'mpirun',\n                    'access':  ['-p cpu'],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'features': [\n                        FEATURES[CPU]\n                    ] + list(SCALES.keys()),\n                },\n                {\n                    'name': 'gpu_partition',\n                    'descr': 'GPU partition'\n                    'scheduler': 'slurm',\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'launcher': 'mpirun',\n                    'access':  ['-p gpu'],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'resources': [\n                        {\n                            'name': '_rfm_gpu',\n                            'options': ['--gpus-per-node={num_gpus_per_node}'],\n                        }\n                    ],\n                    'devices': [\n                        {\n                            'type': DEVICE_TYPES[GPU],\n                            'num_devices': 4,\n                        }\n                    ],\n                    'features': [\n                        FEATURES[CPU],\n                        FEATURES[GPU],\n                    ],\n                    'extras': {\n                        GPU_VENDOR: GPU_VENDORS[NVIDIA],\n                    },\n                },\n            ]\n        }\n    ]\n}\n</code></pre> <p>The most common configuration items defined at this level are:</p> <ul> <li><code>name</code>:   The name of the partition. Pick anything you like.</li> <li><code>descr</code>:   Description of the partition. Again, pick whatever you like.</li> <li><code>scheduler</code>:   The scheduler used to submit to this partition, for example <code>slurm</code>. All valid options can be found   in the ReFrame documentation.</li> <li><code>launcher</code>:   The parallel launcher used on this partition, for example <code>mpirun</code> or <code>srun</code>. All valid options can be found   in the ReFrame documentation.</li> <li><code>access</code>:   A list of arguments that you would normally pass to the scheduler when submitting to this partition   (for example '<code>-p cpu</code>' for submitting to a Slurm partition called <code>cpu</code>).   If supported by your scheduler, we recommend to not export the submission environment   (for example by using '<code>--export=None</code>' with Slurm). This avoids test failures due to environment variables set   in the submission environment that are passed down to submitted jobs.</li> <li><code>prepare_cmds</code>:   Commands to execute at the start of every job that runs a test. If your batch scheduler does not export   the environment of the submit host, this is typically where you can initialize the EESSI environment.</li> <li><code>environs</code>:   The names of the programming environments (to be defined later in the configuration file via <code>environments</code>)   that may be used on this partition. A programming environment is required for tests that are compiled first,   before they can run. The EESSI test suite however only tests existing software installations, so no compilation   (or specific programming environment) is needed. Simply specify <code>'environs': ['default']</code>,   since ReFrame requires that a default environment is defined. </li> <li><code>max_jobs</code>:   The maximum amount of jobs ReFrame is allowed to submit in parallel. Some batch systems limit how many jobs users   are allowed to have in the queue. You can use this to make sure ReFrame doesn't exceed that limit.</li> <li><code>resources</code>:   This field defines how additional resources can be requested in a batch job. Specifically, on a GPU partition,   you have to define a resource with the name '<code>_rfm_gpu</code>'. The <code>options</code> field should then contain the argument to be   passed to the batch scheduler in order to request a certain number of GPUs per node, which could be different for   different batch schedulers. For example, when using Slurm you would specify:   <pre><code>'resources': [\n  {\n      'name': '_rfm_gpu',\n      'options': ['--gpus-per-node={num_gpus_per_node}'],\n  },\n],\n</code></pre></li> <li><code>processor</code>:   We recommend to NOT define this field, unless CPU autodetection is not working for you.   The EESSI test suite relies on information about your processor topology to run. Using CPU autodetection is the   easiest way to ensure that all processor-related information needed by the EESSI test suite are defined.   Only if CPU autodetection is failing for you do we advice you to set the <code>processor</code> in the partition configuration   as an alternative. Although additional fields might be used by future EESSI tests, at this point you'll have to   specify at least the following fields:   <pre><code>'processor': {\n    'num_cpus': 64,  # Total number of CPU cores in a node\n    'num_sockets': 2,  # Number of sockets in a node\n    'num_cpus_per_socket': 32,  # Number of CPU cores per socket\n    'num_cpus_per_core': 1,  # Number of hardware threads per CPU core\n}                 \n</code></pre></li> <li><code>features</code>:   The <code>features</code> field is used by the EESSI test suite to run tests only on a partition if it supports a certain   feature (for example if GPUs are available). Feature names are standardized in the EESSI test suite in   <code>eessi.testsuite.constants.FEATURES</code>   dictionary.   Typically, you want to define <code>features: [FEATURES[CPU]] + list(SCALES.keys())</code> for CPU based partitions, and   <code>features: [FEATURES[GPU]] + list(SCALES.keys())</code> for GPU based partitions. The first tells the EESSI test suite   that this partition can only run CPU-based tests, whereas second indicates that this partition can only run GPU-based   tests. You can define a single partition to have both the CPU and GPU features (since <code>features</code> is a Python list).   However, since the CPU-based tests will not ask your batch scheduler for GPU resources, this may fail on batch   systems that force you to ask for at least one GPU on GPU-based nodes. Also, running CPU-only code on a GPU node is   typically considered bad practice, thus testing its functionality is typically not relevant.   The <code>list(SCALES.keys())</code> adds all the scales that may be used by EESSI tests to the <code>features</code> list. These scales are   defined in   <code>eessi.testsuite.constants.SCALES</code>   and define at which scales tests should be run, e.g. single core, half a node, a full node, two nodes, etc. This   can be used to exclude running at certain scales on systems that would not support it. E.g. some systems might not   support requesting multiple partial nodes, which is what the <code>1_cpn_2_nodes</code> (1 core per node, on two nodes) and   <code>1_cpn_4_nodes</code> scales do. One could exclude these by setting e.g.   <code>features: [FEATURES[CPU]] + [s for s in SCALES if s not in ['1_cpn_2_nodes', '1_cpn_4_nodes']]</code>. With this   configuration setting, ReFrame will run all the scales listed in `eessi.testsuite.constants.SCALES except   those two. In a similar way, one could exclude all multinode tests if one just has a single node available.</li> <li><code>devices</code>: This field specifies information on devices (for example) present in the partition. Device types are standardized in the EESSI test suite in the <code>eessi.testsuite.constants.DEVICE_TYPES</code> dictionary. This is used by the EESSI test suite to determine how many of these devices it can/should use per node.   Typically, there is no need to define <code>devices</code> for CPU partitions.   For GPU partitions, you want to define something like:   <pre><code>'devices': {\n    'type': DEVICE_TYPES[GPU],\n    'num_devices': 4,  # or however many GPUs you have per node\n}\n</code></pre></li> <li><code>extras</code>: This field specifies extra information on the partition, such as the GPU vendor. Valid fields for <code>extras</code> are standardized as constants in <code>eessi.testsuite.constants</code> (for example <code>GPU_VENDOR</code>). This is used by the EESSI test suite to decide if a partition can run a test that specifically requires a certain brand of GPU.   Typically, there is no need to define <code>extras</code> for CPU partitions.   For GPU partitions, you typically want to specify the GPU vendor, for example:   <pre><code>'extras': {\n    GPU_VENDOR: GPU_VENDORS[NVIDIA]\n}\n</code></pre></li> </ul> <p>Note that as more tests are added to the EESSI test suite, the use of <code>features</code>, <code>devices</code> and <code>extras</code> by the EESSI test suite may be extended, which may require an update of your configuration file to define newly recognized fields.</p> <p>Note</p> <p>Keep in mind that ReFrame partitions are virtual entities: they may or may not correspond to a partition as it is configured in your batch system. One might for example have a single partition in the batch system, but configure it as two separate partitions in the ReFrame configuration file based on additional constraints that are passed to the scheduler, see for example the AWS CitC example configuration.</p> <p>The EESSI test suite (and more generally, ReFrame) assumes the hardware within a partition defined in the ReFrame configuration file is homogeneous.</p>"},{"location":"test-suite/ReFrame-configuration-file/#environments","title":"Environments","text":"<p>ReFrame needs a programming environment to be defined in its configuration file for tests that need to be compiled before they are run. While we don't have such tests in the EESSI test suite, ReFrame requires some programming environment to be defined:</p> <pre><code>site_configuration = {\n    ...\n    'environments': [\n        {\n            'name': 'default',  # Note: needs to match whatever we set for 'environs' in the partition\n            'cc': 'cc',\n            'cxx': '',\n            'ftn': '',\n        }\n    ]\n}\n</code></pre> <p>Note</p> <p>The <code>name</code> here needs to match whatever we specified for the <code>environs</code> property of the partitions.</p>"},{"location":"test-suite/ReFrame-configuration-file/#logging","title":"Logging","text":"<p>ReFrame allows a large degree of control over what gets logged, and where. For convenience, we have created a common logging configuration in <code>eessi.testsuite.common_config</code> that provides a reasonable default. It can be used by importing <code>common_logging_config</code> and calling it as a function to define the '<code>logging</code> setting: <pre><code>from eessi.testsuite.common_config import common_logging_config\n\nsite_configuration = {\n    ...\n    'logging':  common_logging_config(),\n}\n</code></pre> When combined by setting the <code>$RFM_PREFIX</code> environment variable, the output, performance log, and regular ReFrame logs will all end up in the directory specified by <code>$RFM_PREFIX</code>, which we recommend doing.</p> <p>Alternatively, a prefix can be passed as an argument like <code>common_logging_config(prefix)</code>, which will control where the regular ReFrame log ends up. Note that the performance logs do not respect this prefix: they will still end up in the standard ReFrame prefix (by default the current directory, unless otherwise set with <code>$RFM_PREFIX</code> or <code>--prefix</code>).</p>"},{"location":"test-suite/ReFrame-configuration-file/#cpu-auto-detection","title":"Auto-detection of processor information","text":"<p>You can let ReFrame auto-detect the processor information for your system.</p> <p>ReFrame will automatically use auto-detection when two conditions are met:</p> <ol> <li>The <code>partitions</code> section of you configuration file does not specify <code>processor</code> information for a    particular partition (as per our recommendation in the previous section);</li> <li>The <code>remote_detect</code> option is enabled in the <code>general</code> part of the configuration, as follows:    <pre><code>site_configuration = {\n    'systems': ...\n    'logging': ...\n    'general': [\n        {\n            'remote_detect': True,\n        }\n    ]\n}\n</code></pre></li> </ol> <p>To trigger the auto-detection of processor information, it is sufficient to let ReFrame list the available tests:</p> <pre><code>reframe --list\n</code></pre> <p>ReFrame will store the processor information for your system in <code>~/.reframe/topology/&lt;system&gt;-&lt;partition&gt;/processor.json</code>.</p>"},{"location":"test-suite/available-tests/","title":"Available tests","text":"<p>The EESSI test suite currently includes tests for:</p> <ul> <li>GROMACS</li> <li>TensorFlow</li> <li>OSU Micro-Benchmarks</li> </ul> <p>For a complete overview of all available tests in the EESSI test suite, see the <code>eessi/testsuite/tests</code> subdirectory in the <code>EESSI/test-suite</code> GitHub repository.</p>"},{"location":"test-suite/available-tests/#gromacs","title":"GROMACS","text":"<p>Several tests for GROMACS, a software package to perform molecular dynamics simulations, are included, which use the systems included in the HECBioSim benchmark suite:</p> <ul> <li><code>Crambin</code> (20K atom system)</li> <li><code>Glutamine-Binding-Protein</code> (61K atom system)</li> <li><code>hEGFRDimer</code> (465K atom system)</li> <li><code>hEGFRDimerSmallerPL</code> (465K atom system, only 10k steps)</li> <li><code>hEGFRDimerPair</code> (1.4M atom system)</li> <li><code>hEGFRtetramerPair</code> (3M atom system)</li> </ul> <p>It is implemented in <code>tests/apps/gromacs.py</code>, on top of the GROMACS test that is included in the ReFrame test library <code>hpctestlib</code>.</p> <p>To run this GROMACS test with all HECBioSim systems, use:</p> <pre><code>reframe --run --name GROMACS\n</code></pre> <p>To run this GROMACS test only for a specific HECBioSim system, use for example:</p> <pre><code>reframe --run --name 'GROMACS.*HECBioSim/hEGFRDimerPair'\n</code></pre> <p>To run this GROMACS test with the smallest HECBioSim system (<code>Crambin</code>), you can use the <code>CI</code> tag:</p> <pre><code>reframe --run --name GROMACS --tag CI\n</code></pre>"},{"location":"test-suite/available-tests/#tensorflow","title":"TensorFlow","text":"<p>A test for TensorFlow, a machine learning framework, is included, which is based on the \"Multi-worker training with Keras\" TensorFlow tutorial.</p> <p>It is implemented in <code>tests/apps/tensorflow/</code>.</p> <p>To run this TensorFlow test, use:</p> <pre><code>reframe --run --name TensorFlow\n</code></pre> <p>Warning</p> <p>This test requires TensorFlow v2.11 or newer, using an older TensorFlow version will not work!</p>"},{"location":"test-suite/available-tests/#osumicrobenchmarks","title":"OSU Micro-Benchmarks","text":"<p>A test for OSU Micro-Benchmarks, which provides an MPI benchmark. </p> <p>It is implemented in <code>tests/apps/osu.py</code>.</p> <p>To run this Osu Micro-Benchmark, use:</p> <pre><code>reframe --run --name OSU-Micro-Benchmarks\n</code></pre> <p>Warning</p> <p>This test requires OSU Micro-Benchmarks v5.9 or newer, using an older OSU -Micro-Benchmark version will not work!</p>"},{"location":"test-suite/installation-configuration/","title":"Installing and configuring the EESSI test suite","text":"<p>This page covers the requirements, installation and configuration of the EESSI test suite.</p>"},{"location":"test-suite/installation-configuration/#requirements","title":"Requirements","text":"<p>The EESSI test suite requires </p> <ul> <li>Python &gt;= 3.6 </li> <li>ReFrame v4.3.3 (or newer)</li> <li>ReFrame test library (<code>hpctestlib</code>)</li> </ul>"},{"location":"test-suite/installation-configuration/#installing-reframe","title":"Installing Reframe","text":"<p>General instructions for installing ReFrame are available in the ReFrame documentation. To check if ReFrame is available, run the <code>reframe</code> command:</p> <pre><code>reframe --version\n</code></pre> (for more details on the ReFrame version requirement, click here) <p>Two important bugs were resolved in ReFrame's CPU autodetect functionality in version 4.3.3.</p> <p>We strongly recommend you use <code>ReFrame &gt;= 4.3.3</code>.</p> <p>If you are using an older version of ReFrame, you may encounter some issues:</p> <ul> <li>ReFrame will try to use the parallel launcher command configured for each partition (e.g. <code>mpirun</code>) when doing   the remote autodetect. If there is no system-version of <code>mpirun</code> available, that will fail   (see ReFrame issue #2926).</li> <li>CPU autodetection only worked when using a clone of the ReFrame repository, not when it was installed   with <code>pip</code> or <code>EasyBuild</code> (as is also the case for the ReFrame shipped with EESSI)   (see ReFrame issue #2914).</li> </ul>"},{"location":"test-suite/installation-configuration/#installing-reframe-test-library-hpctestlib","title":"Installing ReFrame test library (<code>hpctestlib</code>)","text":"<p>The EESSI test suite requires that the ReFrame test library (<code>hpctestlib</code>) is available, which is currently not included in a standard installation of ReFrame.</p> <p>We recommend installing ReFrame using EasyBuild (version 4.8.1, or newer), or using a ReFrame installation that is available in the EESSI repository (version 2023.06, or newer).</p> <p>For example (using EESSI):</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load ReFrame/4.3.3\n</code></pre> <p>To check whether the ReFrame test library is available, try importing a submodule of the <code>hpctestlib</code> Python package:</p> <pre><code>python3 -c 'import hpctestlib.sciapps.gromacs'\n</code></pre>"},{"location":"test-suite/installation-configuration/#installation","title":"Installation","text":"<p>To install the EESSI test suite, you can either use <code>pip</code> or clone the GitHub repository directly:</p>"},{"location":"test-suite/installation-configuration/#pip-install","title":"Using <code>pip</code>","text":"<pre><code>pip install git+https://github.com/EESSI/test-suite.git\n</code></pre>"},{"location":"test-suite/installation-configuration/#cloning-the-repository","title":"Cloning the repository","text":"<pre><code>git clone https://github.com/EESSI/test-suite $HOME/EESSI-test-suite\ncd EESSI-test-suite\nexport PYTHONPATH=$PWD:$PYTHONPATH\n</code></pre>"},{"location":"test-suite/installation-configuration/#verify-installation","title":"Verify installation","text":"<p>To check whether the EESSI test suite installed correctly, try importing the <code>eessi.testsuite</code> Python package:</p> <pre><code>python3 -c 'import eessi.testsuite'\n</code></pre>"},{"location":"test-suite/installation-configuration/#configuration","title":"Configuration","text":"<p>Before you can run the EESSI test suite, you need to create a configuration file for ReFrame that is specific to the system on which the tests will be run.</p> <p>Example configuration files are available in the <code>config</code> subdirectory of the <code>EESSI/test-suite</code> GitHub repository](https://github.com/EESSI/test-suite/tree/main/config), which you can use as a template to create your own.</p>"},{"location":"test-suite/installation-configuration/#configuring-reframe-environment-variables","title":"Configuring ReFrame environment variables","text":"<p>We recommend setting a couple of <code>$RFM_*</code> environment variables to configure ReFrame, to avoid needing to include particular options to the <code>reframe</code> command over and over again.</p>"},{"location":"test-suite/installation-configuration/#RFM_CONFIG_FILES","title":"ReFrame configuration file (<code>$RFM_CONFIG_FILES</code>)","text":"<p>(see also <code>RFM_CONFIG_FILES</code> in ReFrame docs)</p> <p>Define the <code>$RFM_CONFIG_FILES</code> environment variable to instruct ReFrame which configuration file to use, for example:</p> <pre><code>export RFM_CONFIG_FILES=$HOME/EESSI-test-suite/config/example.py\n</code></pre> <p>Alternatively, you can use the <code>--config-file</code> (or <code>-C</code>) <code>reframe</code> option.</p> <p>See the section on the ReFrame configuration file below for more information.</p>"},{"location":"test-suite/installation-configuration/#search-path-for-tests-rfm_check_search_path","title":"Search path for tests (<code>$RFM_CHECK_SEARCH_PATH</code>)","text":"<p>(see also <code>RFM_CHECK_SEARCH_PATH</code> in ReFrame docs)</p> <p>Define the <code>$RFM_CHECK_SEARCH_PATH</code> environment variable to tell ReFrame which directory to search for tests.</p> <p>In addition, define <code>$RFM_CHECK_SEARCH_RECURSIVE</code> to ensure that ReFrame searches <code>$RFM_CHECK_SEARCH_PATH</code> recursively (i.e. so that also tests in subdirectories are found).</p> <p>For example:</p> <pre><code>export RFM_CHECK_SEARCH_PATH=$HOME/EESSI-test-suite/eessi/testsuite/tests\nexport RFM_CHECK_SEARCH_RECURSIVE=1\n</code></pre> <p>Alternatively, you can use the <code>--checkpath</code> (or <code>-c</code>) and <code>--recursive</code> (or <code>-R</code>) <code>reframe</code> options.</p>"},{"location":"test-suite/installation-configuration/#RFM_PREFIX","title":"ReFrame prefix (<code>$RFM_PREFIX</code>)","text":"<p>(see also <code>RFM_PREFIX</code> in ReFrame docs)</p> <p>Define the <code>$RFM_PREFIX</code> environment variable to tell ReFrame where to store the files it produces. E.g.</p> <pre><code>export RFM_PREFIX=$HOME/reframe_runs\n</code></pre> <p>This involves:</p> <ul> <li>test output directories (which contain e.g. the job script, stderr and stdout for each of the test jobs)</li> <li>staging directories (unless otherwise specified by <code>staging</code>, see below);</li> <li>performance logs;</li> </ul> <p>Note that the default is for ReFrame to use the current directory as prefix. We recommend setting a prefix so that logs are not scattered around and nicely appended for each run.</p> <p>If our common logging configuration is used, the regular ReFrame log file will also end up in the location specified by <code>$RFM_PREFIX</code>.</p> <p>Warning</p> <p>Using the <code>--prefix</code> option in your <code>reframe</code> command is not equivalent to setting <code>$RFM_PREFIX</code>, since our common logging configuration only picks up on the <code>$RFM_PREFIX</code> environment variable to determine the location for the ReFrame log file.</p>"},{"location":"test-suite/release-notes/","title":"Release notes for EESSI test suite","text":""},{"location":"test-suite/release-notes/#010","title":"0.1.0","text":"<p>Version 0.1.0 is the first release of the EESSI test suite.</p> <p>It includes:</p> <ul> <li>A well-structured <code>eessi.testsuite</code> Python package that provides constants,   utilities,   hooks,   and tests,   which can be installed with \"<code>pip install</code>\".</li> <li>Tests for GROMACS and TensorFlow in <code>eessi.testsuite.tests.apps</code>   that leverage the functionality provided by <code>eessi.testsuite.*</code>.</li> <li>Examples of ReFrame configuration files for various systems in   the <code>config</code> subdirectory.</li> <li>A <code>common_logging_config()</code> function to facilitate the ReFrame logging configuration.</li> <li>A set of standard device types and features that can be used in the <code>partitions</code> section of the ReFrame configuration file.</li> <li>A set of tags (<code>CI</code> + <code>scale</code>) that can be used to filter checks.</li> <li>Scripts that show how to run the test suite.</li> </ul>"},{"location":"test-suite/usage/","title":"Using the EESSI test suite","text":"<p>This page covers the usage of the EESSI test suite.</p> <p>We assume you have already installed and configured the EESSI test suite on your system.</p>"},{"location":"test-suite/usage/#listing-available-tests","title":"Listing available tests","text":"<p>To list the tests that are available in the EESSI test suite, use <code>reframe --list</code> (or <code>reframe -L</code> for short).</p> <p>If you have properly configured ReFrame, you should see a (potentially long) list of checks in the output:</p> <pre><code>$ reframe --list\n...\n[List of matched checks]\n- ...\nFound 123 check(s)\n</code></pre> <p>Note</p> <p>When using <code>--list</code>, checks are only generated based on modules that are available in the system where the <code>reframe</code> command is invoked.</p> <p>The system partitions specified in your ReFrame configuration file are not taken into account when using <code>--list</code>.</p> <p>So, if <code>--list</code> produces an overview of 50 checks, and you have 4 system partitions in your configuration file, actually running the test suite may result in (up to) 200 checks being executed.</p>"},{"location":"test-suite/usage/#dry-run","title":"Performing a dry run","text":"<p>To perform a dry run of the EESSI test suite, use <code>reframe --dry-run</code>:</p> <pre><code>$ reframe --dry-run\n...\n[==========] Running 1234 check(s)\n\n[----------] start processing checks\n[ DRY      ] GROMACS_EESSI ...\n...\n[----------] all spawned checks have finished\n\n[  PASSED  ] Ran 1234/1234 test case(s) from 1234 check(s) (0 failure(s), 0 skipped, 0 aborted)\n</code></pre> <p>Note</p> <p>When using <code>--dry-run</code>, the systems partitions listed in your ReFrame configuration file are also taken into account when generating checks, next to available modules and test parameters, which is not the case when using <code>--list</code>.</p>"},{"location":"test-suite/usage/#running-the-full-test-suite","title":"Running the (full) test suite","text":"<p>To actually run the (full) EESSI test suite and let ReFrame produce a performance report, use <code>reframe --run --performance-report</code>.</p> <p>We strongly recommend filtering the checks that will be run by using additional options like <code>--system</code>, <code>--name</code>, <code>--tag</code> (see the 'Filtering tests' section below), and doing a dry run first to make sure that the generated checks correspond to what you have in mind.</p>"},{"location":"test-suite/usage/#reframe-output-and-log-files","title":"ReFrame output and log files","text":"<p>ReFrame will generate various output and log files:</p> <ul> <li>a general ReFrame log file with debug logging on the ReFrame run (incl. selection of tests, generating checks,   test results, etc.);</li> <li>stage directories for each generated check, in which the checks are run;</li> <li>output directories for each generated check, which include the test output;</li> <li>performance log files for each test, which include performance results for the test runs;</li> </ul> <p>We strongly recommend controlling where these files go by using the common logging configuration that is provided by the EESSI test suite in your ReFrame configuration file and setting <code>$RFM_PREFIX</code> (avoid using the cmd line option <code>--prefix</code>).</p> <p>If you do, and if you use ReFrame v4.3.3 or more newer, you should find the output and log files at:</p> <ul> <li>general ReFrame log file at <code>$RFM_PREFIX/logs/reframe_&lt;datestamp&gt;_&lt;timestamp&gt;.log</code>;</li> <li>stage directories in <code>$RFM_PREFIX/stage/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> <li>output directories in <code>$RFM_PREFIX/output/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> <li>performance log files in <code>$RFM_PREFIX/perflogs/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> </ul> <p>In the stage and output directories, there will be a subdirectory for each check that was run, which are tagged with a unique hash (like <code>d3adb33f</code>) that is determined based on the specific parameters for that check (see the ReFrame documentation for more details on the test naming scheme).</p>"},{"location":"test-suite/usage/#filtering-tests","title":"Filtering tests","text":"<p>By default, ReFrame will automatically generate checks for each system partition, based on the tests available in the EESSI test suite, available software modules, and tags defined in the EESSI test suite.</p> <p>To avoid being overwhelmed by checks, it is recommend to apply filters so ReFrame only generates the checks you are interested in.</p>"},{"location":"test-suite/usage/#filter-name","title":"Filtering by test name","text":"<p>You can filter checks based on the full test name using the <code>--name</code> option (or <code>-n</code>), which includes the value for all test parameters.</p> <p>Here's an example of a full test name:</p> <pre><code>GROMACS_EESSI %benchmark_info=HECBioSim/Crambin %nb_impl=cpu %scale=1_node %module_name=GROMACS/2023.1-foss-2022a /d3adb33f @example:gpu+default\n</code></pre> <p>To let ReFrame only generate checks for GROMACS, you can use:</p> <pre><code>reframe --name GROMACS\n</code></pre> <p>To only run GROMACS checks with a particular version of GROMACS, you can use <code>--name</code> to only retain specific <code>GROMACS</code> modules:</p> <pre><code>reframe --name %module_name=GROMACS/2023.1\n</code></pre> <p>Likewise, you can filter on any part of the test name.</p> <p>You can also select one specific check using the corresponding test hash, which is also part of the full test name (see <code>/d3adb33f</code> in the example above): for example:</p> <pre><code>reframe --name /d3adb33f\n</code></pre> <p>The argument passed to <code>--name</code> is interpreted as a Python regular expression, so you can use wildcards like <code>.*</code>, character ranges like <code>[0-9]</code>, use <code>^</code> to specify that the pattern should match from the start of the test name, etc.</p> <p>Use <code>--list</code> or <code>--dry-run</code> to check the impact of using the <code>--name</code> option.</p>"},{"location":"test-suite/usage/#filter-system-partition","title":"Filtering by system (partition)","text":"<p>By default, ReFrame will generate checks for each system partition that is listed in your configuration file.</p> <p>To only let ReFrame checks for a particular system or system partition, you can use the <code>--system</code> option.</p> <p>For example:</p> <ul> <li>To let ReFrame only generate checks for the system named <code>example</code>, use:   <pre><code>reframe --system example ...\n</code></pre></li> <li>To let ReFrame only generate checks for the <code>gpu</code> partition of the system named <code>example</code>, use:   <pre><code>reframe --system example:gpu ...\n</code></pre></li> </ul> <p>Use <code>--dry-run</code> to check the impact of using the <code>--system</code> option.</p>"},{"location":"test-suite/usage/#filter-tag","title":"Filtering by tags","text":"<p>To filter tests using one or more tags, you can use the <code>--tag</code> option.</p> <p>Using <code>--list-tags</code> you can get a list of known tags.</p> <p>To check the impact of this on generated checks by ReFrame, use <code>--list</code> or <code>--dry-run</code>.</p>"},{"location":"test-suite/usage/#ci-tag","title":"<code>CI</code> tag","text":"<p>For each software that is included in the EESSI test suite, a small test is tagged with <code>CI</code> to indicate it can be used in a Continuous Integration (CI) environment.</p> <p>Hence, you can use this tag to let ReFrame only generate checks for small test cases:</p> <pre><code>reframe --tag CI\n</code></pre> <p>For example:</p> <pre><code>$ reframe --name GROMACS --tag CI\n...\n</code></pre>"},{"location":"test-suite/usage/#scale-tags","title":"<code>scale</code> tags","text":"<p>The EESSI test suite defines a set of custom tags that control the scale of checks, which specify many cores/GPUs/nodes should be used for running a check. The number of cores and GPUs serves as an upper limit; the actual count depends on the specific configuration of cores, GPUs, and sockets within the node, as well as the specific test being carried out.</p> tag name description <code>1_core</code> using 1 CPU core 1 GPU <code>2_cores</code> using 2 CPU cores and 1 GPU <code>4_cores</code> using 4 CPU cores and 1 GPU <code>1_cpn_2_nodes</code> using 1 CPU core per node, 1 GPU per node, and 2 nodes <code>1_cpn_4_nodes</code> using 1 CPU core per node, 1 GPU per node, and 4 nodes <code>1_8_node</code> using 1/8th of a node (12.5% of available cores/GPUs, 1 at minimum) <code>1_4_node</code> using a quarter of a node (25% of available cores/GPUs, 1 at minimum) <code>1_2_node</code> using half of a node (50% of available cores/GPUs, 1 at minimum) <code>1_node</code> using a full node (all available cores/GPUs) <code>2_nodes</code> using 2 full nodes <code>4_nodes</code> using 4 full nodes <code>8_nodes</code> using 8 full nodes <code>16_nodes</code> using 16 full nodes"},{"location":"test-suite/usage/#using-multiple-tags","title":"Using multiple tags","text":"<p>To filter tests using multiple tags, you can:</p> <ul> <li>use <code>|</code> as separator to indicate that one of the specified tags must match (logical OR, for example <code>--tag='1_core|2_cores'</code>);</li> <li>use the <code>--tag</code> option multiple times to indicate that all specified tags must match (logical AND, for example <code>--tag CI --tag 1_core</code>);</li> </ul>"},{"location":"test-suite/usage/#example-commands","title":"Example commands","text":"<p>Running all GROMACS tests on 4 cores on the <code>cpu</code> partition</p> <pre><code>reframe --run --system example:cpu --name GROMACS --tag 4_cores --performance-report\n</code></pre> <p>List all checks for TensorFlow 2.11 using a single node</p> <pre><code>reframe --list --name %module_name=TensorFlow/2.11 --tag 1_node\n</code></pre> <p>Dry run of TensorFlow CI checks on a quarter (1/4) of a node (on all system partitions)</p> <pre><code>reframe --dry-run --name 'TensorFlow.*CUDA' --tag 1_4_node --tag CI\n</code></pre>"},{"location":"test-suite/usage/#overriding-test-parameters-advanced","title":"Overriding test parameters (advanced)","text":"<p>You can override test parameters using the <code>--setvar</code> option (or <code>-S</code>).</p> <p>This can be done either globally (for all tests), or only for specific tests (which is recommended when using <code>--setvar</code>).</p> <p>For example, to run all GROMACS checks with a specific GROMACS module, you can use:</p> <pre><code>reframe --setvar GROMACS_EESSI.modules=GROMACS/2023.1-foss-2022a ...\n</code></pre> <p>Warning</p> <p>We do not recommend using <code>--setvar</code>, since it is quite easy to make unintended changes to test parameters this way that can result in broken checks.</p> <p>You should try filtering tests using the <code>--name</code> or <code>--tag</code> options instead.</p>"},{"location":"using_eessi/basic_commands/","title":"Basic commands","text":""},{"location":"using_eessi/basic_commands/#basic-commands-to-access-software-provided-via-eessi","title":"Basic commands to access software provided via EESSI","text":"<p>EESSI provides software through environment module files and Lmod.</p> <p>To see which modules (and extensions) are available, run:</p> <pre><code>module avail\n</code></pre> <p>Below is a short excerpt of the output produced by <code>module avail</code>, showing 10 modules only. <pre><code>   PyYAML/5.3-GCCcore-9.3.0\n   Qt5/5.14.1-GCCcore-9.3.0\n   Qt5/5.15.2-GCCcore-10.3.0                               (D)\n   QuantumESPRESSO/6.6-foss-2020a\n   R-bundle-Bioconductor/3.11-foss-2020a-R-4.0.0\n   R/4.0.0-foss-2020a\n   R/4.1.0-foss-2021a                                      (D)\n   re2c/1.3-GCCcore-9.3.0\n   re2c/2.1.1-GCCcore-10.3.0                               (D)\n   RStudio-Server/1.3.1093-foss-2020a-Java-11-R-4.0.0\n</code></pre></p> <p>Load modules with <code>module load package/version</code>, e.g., <code>module load R/4.1.0-foss-2021a</code>, and try out the software. See below for a short session</p> <pre><code>[EESSI 2023.06] $ module load R/4.1.0-foss-2021a\n[EESSI 2021.06] $ which R\n/cvmfs/software.eessi.io/versions/2021.12/software/linux/x86_64/intel/skylake_avx512/software/R/4.1.0-foss-2021a/bin/R\n[EESSI 2023.06] $ R --version\nR version 4.1.0 (2021-05-18) -- \"Camp Pontanezen\"\nCopyright (C) 2021 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under the terms of the\nGNU General Public License versions 2 or 3.\nFor more information about these matters see\nhttps://www.gnu.org/licenses/.\n</code></pre>"},{"location":"using_eessi/building_on_eessi/","title":"Building software on top of EESSI","text":""},{"location":"using_eessi/building_on_eessi/#building-software-on-top-of-eessi-with-easybuild","title":"Building software on top of EESSI with EasyBuild","text":"<p>Building on top of EESSI with EasyBuild is relatively straightforward. One crucial feature is that EasyBuild supports building against operating system libraries that are not in a standard prefix (such as <code>/usr/lib</code>). This is required when building against EESSI, since all of the software in EESSI is built against the compatibility layer.</p>"},{"location":"using_eessi/building_on_eessi/#starting-the-eessi-software-environment","title":"Starting the EESSI software environment","text":"<p>Start your environment as described here</p>"},{"location":"using_eessi/building_on_eessi/#configure-easybuild","title":"Configure EasyBuild","text":"<p>To configure EasyBuild, first, check out the EESSI software-layer repository. We advise you to check out the branch corresponding to the version of EESSI you would like to use.</p> <p>If you are unsure which version you are using, you can run <pre><code>echo ${EESSI_PILOT_VERSION}\n</code></pre> to check it.</p> <p>To build on top of e.g. version <code>2023.06</code> of the EESSI software stack, we check it out, and go into that directory:</p> <p><pre><code>git clone https://github.com/EESSI/software-layer/ --branch 2023.06\ncd software-layer\n</code></pre> Then, you have to pick a working directory (that you have write access to) where EasyBuild can do the build, and an install directory (with sufficient storage space), where EasyBuild can install it. In this example, we create a temporary directory in <code>/tmp/</code> as our working directory, and use <code>$HOME/.local/easybuild</code> as our installpath: <pre><code>export WORKDIR=$(mktemp --directory --tmpdir=/tmp  -t eessi-build.XXXXXXXXXX)\nsource configure_easybuild\nexport EASYBUILD_INSTALLPATH=\"${HOME}/.local/easybuild\"\n</code></pre> Next, you load the EasyBuild module that you want to use, e.g.  <pre><code>module load EasyBuild/4.8.2\n</code></pre> Finally, you can check the current configuration for EasyBuild using <pre><code>eb --show-config\n</code></pre></p> <p>Note</p> <p>We use EasyBuild's default behaviour in optimizing for the host architecture. Since the EESSI initialization script also loads the EESSI stack that is optimized for your host architecture, this matches nicely. However, if you work on a cluster with heterogeneous node types, you have to realize you can only use these builds on the same architecture as where you build them. You can use different <code>EASYBUILD_INSTALLPATH</code>s if you want to build for different host architectures. For example, when you are on a system that has a mix of <code>AMD zen3</code> and <code>AMD zen4</code> nodes, you might want to use <code>EASYBUILD_INSTALLPATH=$HOME/.local/easybuild/zen3</code> when building on a <code>zen3</code> node, <code>EASYBUILD_INSTALLPATH=$HOME/.local/easybuild/zen4</code> when building on a <code>zen4</code> node. Then, in the step beloww, instead of the <code>module use</code> command listed there, you can use <code>module use $HOME/.local/easybuild/zen3/modules/all</code> when you want to run on a <code>zen3</code> node and <code>module use $HOME/.local/easybuild/zen4/modules/all</code> when you want to run on a <code>zen4</code> node.</p>"},{"location":"using_eessi/building_on_eessi/#building","title":"Building","text":"<p>Now, you are ready to build. For example, at the time of writing, <code>netCDF-4.9.0-gompi-2022a.eb</code> was not in the EESSI environment yet, so you can build it yourself: <pre><code>eb netCDF-4.9.0-gompi-2022a.eb\n</code></pre></p> <p>Note</p> <p>If this netCDF module is available by the time you are trying, you can force a local rebuild by adding the <code>--rebuild</code> argument in order to experiment with building locally, or pick a different EasyConfig to build.</p>"},{"location":"using_eessi/building_on_eessi/#using-the-newly-built-module","title":"Using the newly built module","text":"<p>First, you'll need to add the subdirectory of the <code>EASYBUILD_INSTALLPATH</code> that contains the modules to the <code>MODULEPATH</code>. You can do that using:</p> <pre><code>module use ${EASYBUILD_INSTALLPATH}/modules/all\n</code></pre> <p>you may want to do this as part of your <code>.bashrc</code>.</p> <p>Note</p> <p>Be careful adding to the <code>MODULEPATH</code> in your <code>.bashrc</code> if you are on a cluster with heterogeneous architectures. You don't want to pick up on a module that was not compiled for the correct architectures accidentally.</p> <p>Since your module is built on top of the EESSI environment, that needs to be loaded first (as described here), if you haven't already done so.</p> <p>Finally, you should be able to load our newly build module: <pre><code>module load netCDF/4.9.0-gompi-2022a\n</code></pre></p>"},{"location":"using_eessi/building_on_eessi/#manually-building-software-op-top-of-eessi","title":"Manually building software op top of EESSI","text":"<p>Building software on top of EESSI would require your linker to use the same system-dependencies as the software in EESSI does. In other words: it requires you to link against libraries from the compatibility layer, instead of from your host OS.</p> <p>While we plan to support this in the future, manually building on top of EESSI is currently not supported yet in a trivial way.</p>"},{"location":"using_eessi/eessi_demos/","title":"Running EESSI demos","text":"<p>To really experience how using EESSI can significantly facilitate the work of researchers, we recommend running one or more of the EESSI demos.</p> <p>First, clone the <code>eessi-demo</code> Git repository, and move into the resulting directory:</p> <pre><code>git clone https://github.com/EESSI/eessi-demo.git\ncd eessi-demo\n</code></pre> <p>The contents of the directory should be something like this:</p> <pre><code>$ ls -l\ndrwxr-xr-x  5 example  users    160 Nov 23  2020 Bioconductor\ndrwxr-xr-x  3 example  users     96 Jan 26 20:17 CitC\ndrwxr-xr-x  5 example  users    160 Jan 26 20:17 GROMACS\n-rw-r--r--  1 example  users  18092 Jan 26 20:17 LICENSE\ndrwxr-xr-x  3 example  users     96 Jan 26 20:17 Magic_Castle\ndrwxr-xr-x  4 example  users    128 Nov 24  2020 OpenFOAM\n-rw-r--r--  1 example  users    546 Jan 26 20:17 README.md\ndrwxr-xr-x  5 example  users    160 Nov 23  2020 TensorFlow\ndrwxr-xr-x  6 example  users    192 Jan 26 20:17 scripts\n</code></pre> <p>The directories we care about are those that correspond to particular scientific software, like <code>Bioconductor</code>, <code>GROMACS</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, ...</p> <p>Each of these contains a <code>run.sh</code> script that can be used to start a small example run with that software. Every example takes a couple of minutes to run, even with limited resources only.</p>"},{"location":"using_eessi/eessi_demos/#example-running-tensorflow","title":"Example: running TensorFlow","text":"<p>Let's try running the TensorFlow example.</p> <p>First, we need to make sure that our environment is set up to use EESSI:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>Change to the <code>TensorFlow</code> subdirectory of the <code>eessi-demo</code> Git repository, and execute the <code>run.sh</code> script:</p> <pre><code>[EESSI 2023.06] $ cd TensorFlow\n[EESSI 2023.06] $ ./run.sh\n</code></pre> <p>Shortly after starting the script you should see output as shown below, which indicates that GROMACS has started running:</p> <pre><code>Epoch 1/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.2983 - accuracy: 0.9140\nEpoch 2/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.1444 - accuracy: 0.9563\nEpoch 3/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.1078 - accuracy: 0.9670\nEpoch 4/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.0890 - accuracy: 0.9717\nEpoch 5/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.0732 - accuracy: 0.9772\n313/313 - 0s - loss: 0.0679 - accuracy: 0.9790 - 391ms/epoch - 1ms/step\n\nreal   1m24.645s\nuser   0m16.467s\nsys    0m0.910s\n</code></pre>"},{"location":"using_eessi/setting_up_environment/","title":"Setting up your environment","text":"<p>To set up the EESSI environment, simply run the command:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>This may take a while as data is downloaded from a Stratum 1 server which is part of the CernVM-FS infrastructure to distribute files. You should see the following output:</p> <pre><code>Found EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\narchdetect says x86_64/amd/zen2\nUsing x86_64/amd/zen2 as software subdirectory.\nUsing /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all as the directory to be added to MODULEPATH.\nFound Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/.lmod/lmodrc.lua\nInitializing Lmod...\nPrepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (2023.06), have fun!\n{EESSI 2023.06} [user@system ~]$ # (2)!\n</code></pre> <ol> <li>What is reported here depends on the CPU architecture of the machine you are     running the <code>source</code> command.</li> <li>This is the prompt indicating that you have access to the EESSI software     stack.</li> </ol> <p>The last line is the shell prompt.</p> <p> Your environment is now set up, you are ready to start running software provided by EESSI!</p>"}]}